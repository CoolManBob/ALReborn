//@{ Jaewon 20041209
// copied from rtltmap & modified.
//@} Jaewon
/*===========================================================================*
 *-                                                                         -*
 *-  Module  :   AcuRtAmbOcclMap.c                                          -*
 *-                                                                         -*
 *-  Purpose :   RtAmbOcclMap toolkit                                       -*
 *-                                                                         -*
 *===========================================================================*/

/*===========================================================================*
 *--- Include files ---------------------------------------------------------*
 *===========================================================================*/

/* Needed for memset */
#include "string.h"

#include "rwcore.h"
#include "rpworld.h"
#include "rprandom.h"

#include "rpcollis.h"
#include "rtbary.h"

#include "rpdbgerr.h"

#include "rppvs.h"
#include "AcuRpMatD3DFx.h"
#include "AcuRtAmbOcclMap.h"

#include "polypack.h"
#include "ltmapvar.h"

/* In the RtLtMap[Something]CalculateDensity () functions, the total surface
 * area of the object in question is mapped onto the lightmap pixels as if
 * they would match up exactly.  They don't, for two reasons:
 *   1) There's padding around PolySets in the lightmaps, wasting pixels
 *   2) Not all tris will be mapped 'square on' to the camera, saving pixels
 * This fudge factor shrinks the density slightly to err on the side of
 * getting all the object onto a single light map, rather than accidently
 * spilling a few polysets onto a new, completely empty, lightmap */
#define DENSITY_FUDGE_FACTOR 0.68f;

#ifdef SHOWLIGHTMAPUSAGE
#   include "image.h"
#endif

/**
 * \ingroup rtambocclmap
 * \page rtambocclmapoverview RtAmbOcclMap Toolkit Overview
 *
 * \par Requirements
 * \li \b Headers: rwcore.h, rpworld.h, rprandom.h, rpltmap.h, rtltmap.h
 * \li \b Libraries: rwcore, rpworld, rpcollis, rprandom, rpltmap, rppvs, rtbary, rtintsec, rtltmap
 * \li \b Plugin \b attachments: \ref RpWorldPluginAttach, \ref RpCollisionPluginAttach,
 *     \ref RpRandomPluginAttach, \ref RpLtMapPluginAttach, \ref RpPVSPluginAttach
 *
 * \subsection ambocclmaptoolkitoverview Overview
 *
 * The \ref rtambocclmap toolkit contains a suite of functionality for
 * generating lightmaps. The process of lightmap generation consists
 * of two main stages. Firstly, lightmaps need to be allocated and
 * associated with objects, and the UV coordinates for the lightmap
 * pass need to be calculated (see \ref RtAmbOcclMapAmbOcclMapsCreate).
 * Secondly, color values need to be calculated for lightmap texels
 * and, optionally, vertex prelight colors (see \ref RtAmbOcclMapIlluminate).
 *
 * Lightmaps generated by this toolkit support tristripped geometry
 * (unusual for lightmap implementations) and so will render very quickly,
 * especially on such platforms as PlayStation 2. A few visual artifacts remain due
 * to this tristrip support, though they will, in the vast majority of cases,
 * go unnoticed or easily be worked around.
 *
 * Lighting calculations support the standard \ref RpLight types, as well as
 * area light sources, specified with normal geometry on a per-material basis
 * (\ref RtLtMapAreaLightGroupCreate). Area lighting can produce very
 * convincing lighting solutions, with subtle gradients and soft shadows.
 */


/*===========================================================================*
 *--- Local Global Variables ------------------------------------------------*
 *===========================================================================*/
#if (defined(RWDEBUG))
long _rtLtMapStackDepth = 0;
#endif /* (defined(RWDEBUG)) */

/*===========================================================================*
 *--- Local defines ---------------------------------------------------------*
 *===========================================================================*/

/* The extra 4 byte are for version number */
#define AMBOCCLMAPMATERIALSTREAMDATASIZE    \
    (4 + sizeof(AmbOcclMapMaterialStreamData))
#define AMBOCCLMAPOBJECTSTREAMDATASIZE      \
    (4 + sizeof(AmbOcclMapObjectStreamData))
#define AMBOCCLMAPWORLDSTREAMDATASIZE       \
    (4 + sizeof(AmbOcclMapWorldStreamData))

/*===========================================================================*
 *--- Local types -----------------------------------------------------------*
 *===========================================================================*/
typedef struct _rtdensityCalculateData _rtdensityCalculateData;

struct _rtdensityCalculateData
{
    RwReal area;
    RwInt32 numWS;
};

/*===========================================================================*
 *--- Local variables -------------------------------------------------------*
 *===========================================================================*/


/*===========================================================================*
 *--- Global Variables ------------------------------------------------------*
 *===========================================================================*/

AmbOcclMapGlobals _rpAmbOcclMapGlobals;

RwChar rpAmbOcclMapDefaultPrefixString[] = RWSTRING("aomp");
RwChar rpAmbOcclMapImageExtension[]      = RWSTRING(".png");

rtLtMapGlobalVars rtLtMapGlobals = {

    {{ 0.0f, 0.0f, 1.0f},
     { 1.0f, 0.0f, 0.0f},
     { 0.0f, 1.0f, 0.0f},
     { 0.0f, 0.0f, 1.0f},
     { 1.0f, 0.0f, 0.0f},
     { 0.0f, 1.0f, 0.0f}},  /* right vector */

    {{ 0.0f, 1.0f, 0.0f},
     { 0.0f, 0.0f, 1.0f},
     { 1.0f, 0.0f, 0.0f},
     { 0.0f, 1.0f, 0.0f},
     { 0.0f, 0.0f, 1.0f},
     { 1.0f, 0.0f, 0.0f}},  /* up vector */

    { 0.0f, 0.0f, 0.0f },   /* sort vector */

    NULL,                   /* ltMapSlots */

    0,      /* skyFlags */
    NULL,   /* visibility callback */
    0.95f,  /* vis collision scalar */

    NULL,               /* current lighting world */
    rpLIGHTLIGHTWORLD,  /* light object flag */

    NULL,                           /* ltMap post process callback */

    {{{0, 0, 0}, {0, 0, 0}, 0, {NULL, NULL, NULL}}, 0, FALSE},

#if (defined(SHOWLIGHTMAPUSAGE))
    (RwImage *)NULL /* ltMap usage image name */
#endif /* (defined(SHOWLIGHTMAPUSAGE)) */

};

/*===========================================================================*
 *--- Local functions -------------------------------------------------------*
 *===========================================================================*/

/****************************************************************************
 LtMapWorldSectorGatherAtomics
 */
static RpAtomic *
LtMapWorldSectorGatherAtomics(RpAtomic *atomic, void *data)
{
    LtMapSessionInfo *sessionInfo = (LtMapSessionInfo *)data;
    RwBool    found = FALSE;
    RwInt32   i;

    RWFUNCTION(RWSTRING("LtMapWorldSectorGatherAtomics"));

    /* Given that atomics can overlap multiple worldsectors,
     * ensure that we don't add any atomic more than once: */
    if (RWSRCGLOBAL(renderFrame) == atomic->renderFrame)
    {
        RWRETURN(atomic);
    }
    atomic->renderFrame = RWSRCGLOBAL(renderFrame);

    if (NULL != sessionInfo->session->atomicList)
    {
        /* Only add items in the pre-provided list */
        for (i = 0;i < sessionInfo->session->numAtomics;i++)
        {
            if (atomic == sessionInfo->session->atomicList[i])
            {
                found = TRUE;
                break;
            }
        }
        if (FALSE == found)
            RWRETURN(atomic);
    }

    if ((FALSE != sessionInfo->useCamera) && (NULL != sessionInfo->session->camera) )
    {
        /* Frustum-test the object */
        if (rwSPHEREOUTSIDE == RwCameraFrustumTestSphere(
                sessionInfo->session->camera, RpAtomicGetWorldBoundingSphere(atomic)) )
        {
            RWRETURN(atomic);
        }
    }

    RWASSERT(NULL != sessionInfo->localAtomics);
   *(RpAtomic **)rwSListGetNewEntry(sessionInfo->localAtomics,
       rwID_AMBOCCLMAPPLUGIN | rwMEMHINTDUR_EVENT) = atomic;

    RWRETURN(atomic);
}

/****************************************************************************
 LtMapWorldSectorGather
 */
static RpWorldSector *
LtMapWorldSectorGather(RpWorldSector *sector, void *data)
{
    LtMapSessionInfo *sessionInfo = (LtMapSessionInfo *)data;
    //RwInt32   i;

    RWFUNCTION(RWSTRING("LtMapWorldSectorGather"));

    /* Add all contained atomics into the list */
    if (-1 != sessionInfo->session->numAtomics)
    {
        RpWorldSectorForAllAtomics(sector, LtMapWorldSectorGatherAtomics, data);
    }

    RWRETURN(sector);
}

/****************************************************************************
 _rtLtMapLightingSessionInfoCreate
 */
LtMapSessionInfo *
_rtLtMapLightingSessionInfoCreate(LtMapSessionInfo       *sessionInfo,
                               RtAmbOcclMapLightingSession *session,
                               RwBool                  useCamera)
{
    RwInt32 i;

    /* This function gets called by lightMapCreate/Clear/Destroy, illuminate
     * and areaLightGroupCreate - in each case, different sets of objects are
     * required, so we don't do any culling (on, e.g rpATOMICRENDER) in here
     * and the calling function just ignored certain items in the list. */

    RWFUNCTION(RWSTRING("_rtLtMapLightingSessionInfoCreate"));

    RWASSERT(NULL != sessionInfo);
    RWASSERT(NULL != session);
    sessionInfo->session   = session;
    sessionInfo->useCamera = useCamera;

    /* numAtomics/numSectors being '-1' prevents us from gathering atomics/sectors */

    _rwFrameSyncDirty();

    if (-1 == session->numAtomics)
    {
        sessionInfo->localAtomics = NULL;
    }
    else
    {
        sessionInfo->localAtomics = rwSListCreate(sizeof(RpAtomic *),
                              rwID_ATOMIC | rwMEMHINTDUR_EVENT);
        RWASSERT(NULL != sessionInfo->localAtomics);
    }
    /* Hey, we should be lighting *something*! :) */
    RWASSERT((-1 != session->numAtomics));

    /* We update renderFrame to ensure that no atomic gets added to the list twice */
    RWSRCGLOBAL(renderFrame)++;
    if ((NULL != session->camera) && (FALSE != useCamera))
    {
        if (NULL != session->world)
        {
            RWASSERT(session->world == RwCameraGetWorld(session->camera));
        }
        /* Gather atomics and sectors, taking into account the camera and provided lists */
        RwCameraForAllSectorsInFrustum(session->camera, LtMapWorldSectorGather, (void *)sessionInfo);
    }
    else if ((NULL != session->atomicList))
    {
        /* Just copy the atomics and/or sectors from the incoming lists */
        if ((-1 != session->numAtomics) && (NULL != session->atomicList))
        {
            for (i = 0;i < session->numAtomics;i++)
            {
               *(RpAtomic **)rwSListGetNewEntry(sessionInfo->localAtomics,
                    rwID_AMBOCCLMAPPLUGIN | rwMEMHINTDUR_EVENT) = session->atomicList[i];
            }
        }
    }
    else
    {
        /* Gather up all atomics and sectors in the world */
        RWASSERT (NULL != session->world);
        RpWorldForAllWorldSectors(session->world, LtMapWorldSectorGather, (void *)sessionInfo);
    }

    if (NULL != sessionInfo->localAtomics)
    {
        sessionInfo->numAtomics = rwSListGetNumEntries(sessionInfo->localAtomics);
    }
    else
    {
        sessionInfo->numAtomics = 0;
    }

    RWRETURN(sessionInfo);
}

/****************************************************************************
 _rtLtMapLightingSessionInfoDestroy
 */
RwBool
_rtLtMapLightingSessionInfoDestroy(LtMapSessionInfo *sessionInfo)
{
    RWFUNCTION(RWSTRING("_rtLtMapLightingSessionInfoDestroy"));
    RWASSERT(NULL != sessionInfo);

    if (NULL != sessionInfo->localAtomics)
    {
        rwSListDestroy(sessionInfo->localAtomics);
        sessionInfo->localAtomics = (RwSList *)NULL;
    }
    sessionInfo->numAtomics = 0;

    sessionInfo->session   = (RtAmbOcclMapLightingSession *)NULL;
    sessionInfo->useCamera = FALSE;

    RWRETURN(TRUE);
}

/****************************************************************************
 _rtLtMapNameGen
 */
RwChar *
_rtLtMapNameGen(RwChar *result, RwBool addExt)
{
    RwChar   numberString[11];
    RwUInt32 number, prefixLength, numberLength, i, maxCount = 1;

    RWFUNCTION(RWSTRING("_rtLtMapNameGen"));
    RWASSERT(NULL != result);

    /* Work out the max. allowable value given the current prefix string */
    prefixLength = rwstrlen(_rpAmbOcclMapGlobals.prefix);
    numberLength = 8 - prefixLength;
    RWASSERT(numberLength > 0);
    for (i = 0;i < numberLength;i++)
        maxCount *= 10;
    number = _rpAmbOcclMapGlobals.lightMapCount++;
    if (number >= maxCount)
    {
        _rpAmbOcclMapGlobals.lightMapCount = 0;
        number = 0;
        RwDebugSendMessage(rwDEBUGMESSAGE, "LtMapNameGen",
            "Warning: lightmap counter number wrapped around to zero, lightmaps may get overwritten on stream write");
    }

    /* Fill the result w/ the prefix string followed by zeroes */
    RWASSERT(prefixLength <= rpAMBOCCLMAPMAXPREFIXSTRINGLENGTH);
    rwstrcpy(&(result[0]), _rpAmbOcclMapGlobals.prefix);
    for (i = 0;i < numberLength;i++)
        rwstrcat(result, RWSTRING("0"));

    /* Add the number to the end of the string */
    rwsprintf(numberString, "%d", number);
    RWASSERT(rwstrlen(numberString) + prefixLength <= 8);
    rwstrcpy(&(result[8 - rwstrlen(numberString)]), numberString);

    if (FALSE != addExt)
    {
        /* Add the file extension */
        rwstrcat(result, rpAmbOcclMapImageExtension);
    }

    RWRETURN(result);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapMaterialSetAmbOcclMapDensityModifier sets the
 * lightmap density modifier of a given material.
 *
 * The lightmap density modifier multiplies the default lightmap
 * sample density used, within \ref RtAmbOcclMapAmbOcclMapsCreate, for
 * creating lightmaps. This is useful for getting large areas
 * sampled at a low frequency, thus reducing the number of required
 * lightmap texels and speeding up lighting calculations.
 *
 * This function should be called before a call to
 * \ref RtAmbOcclMapAmbOcclMapsCreate in order to have any effect.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  material  A pointer to an \ref RpMaterial
 * \param  density   An \ref RwReal specifying the new lightmap sample
 *                   density modifier for this material
 *
 * \return A pointer to the material on success, otherwise NULL
 *
 * \see RtAmbOcclMapMaterialGetAmbOcclMapDensityModifier
 * \see RtAmbOcclMapMaterialGetFlags
 * \see RtAmbOcclMapMaterialSetFlags
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RpMaterial *
RtAmbOcclMapMaterialSetAmbOcclMapDensityModifier(RpMaterial *material, RwReal density)
{
    AmbOcclMapMaterialData *matData;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapMaterialSetAmbOcclMapDensityModifier"));

    RWASSERT(NULL != material);
    matData = RPAMBOCCLMAPMATERIALGETDATA(material);

    matData->lightMapDensity = density;

    RWRETURN(material);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapMaterialGetAmbOcclMapDensityModifier retrieves the
 * lightmap density modifier of a given material.
 *
 * The lightmap density modifier multiplies the default lightmap
 * sample density used, within \ref RtAmbOcclMapAmbOcclMapsCreate, for
 * creating lightmaps. This is useful for getting large areas
 * sampled at a low frequency, thus reducing the number of required
 * lightmap texels and speeding up lighting calculations.
 *
 * This function should be called before a call to
 * \ref RtAmbOcclMapAmbOcclMapsCreate in order to have any effect.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  material  A pointer to an \ref RpMaterial for which to get
 *                   the lightmap sample density modifier
 *
 * \return The lightmap sample density modifier of the specified material
 *
 * \see RtAmbOcclMapMaterialSetAmbOcclMapDensityModifier
 * \see RtAmbOcclMapMaterialGetFlags
 * \see RtAmbOcclMapMaterialSetFlags
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RwReal
RtAmbOcclMapMaterialGetAmbOcclMapDensityModifier(RpMaterial *material)
{
    AmbOcclMapMaterialData *matData;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapMaterialGetAmbOcclMapDensityModifier"));

    RWASSERT(NULL != material);
    matData = RPAMBOCCLMAPMATERIALGETDATA(material);

    RWRETURN(matData->lightMapDensity);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapMaterialSetFlags sets the lightmap-related flags
 * of a given material.
 *
 * Material flags control material properties relevant to lighting
 * calculations. See \ref RtAmbOcclMapMaterialFlags for further details.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  material  A pointer to an \ref RpMaterial
 * \param  flags     An \ref RwUInt32 specifying the new flags for this material
 *
 * \return A pointer to the material on success, otherwise NULL
 *
 * \see RtAmbOcclMapMaterialGetFlags
 * \see RtAmbOcclMapMaterialSetAmbOcclMapDensityModifier
 * \see RtAmbOcclMapMaterialGetAmbOcclMapDensityModifier
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapIlluminate
 */
RpMaterial *
RtAmbOcclMapMaterialSetFlags(RpMaterial *material, RwUInt32 flags)
{
    AmbOcclMapMaterialData *matData;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapMaterialSetFlags"));

    RWASSERT(NULL != material);
    matData = RPAMBOCCLMAPMATERIALGETDATA(material);

    matData->flags = flags;

    RWRETURN(material);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapMaterialGetFlags retrieves the lightmap-related flags
 * of a given material.
 *
 * Material flags control material properties relevant to lighting
 * calculations. See \ref RtAmbOcclMapMaterialFlags for further details.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  material  A pointer to an \ref RpMaterial
 *
 * \return The material's flags
 *
 * \see RtAmbOcclMapMaterialSetFlags
 * \see RtAmbOcclMapMaterialSetAmbOcclMapDensityModifier
 * \see RtAmbOcclMapMaterialGetAmbOcclMapDensityModifier
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapIlluminate
 */
RwUInt32
RtAmbOcclMapMaterialGetFlags(RpMaterial *material)
{
    AmbOcclMapMaterialData *matData;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapMaterialGetFlags"));

    RWASSERT(NULL != material);
    matData = RPAMBOCCLMAPMATERIALGETDATA(material);

    RWRETURN(matData->flags);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAtomicGetNumSamples returns the number of lighting samples
 * in a given atomic.
 *
 * An atomic may have both lightmap and vertex prelight samples (depending
 * on its flags - see \ref RtAmbOcclMapObjectFlags - and whether or not it has
 * had a lightmap created for it yet).
 *
 * Note that a returned value of zero does not indicate an error, merely
 * that no lighting samples were found in the supplied atomic.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an atomic
 *
 * \return The number of lightmap samples in the atomic on success, otherwise '-1'.
 *
 * \see RtAmbOcclMapLightingSessionGetNumSamples
 * \see RtAmbOcclMapIlluminate
 */
RwInt32
RtAmbOcclMapAtomicGetNumSamples(RpAtomic *atomic)
{
    AmbOcclMapObjectData *objectData;
    RwInt32 numSamples;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAtomicGetNumSamples"));

    RWASSERT(NULL != atomic);
    objectData = RPAMBOCCLMAPATOMICGETDATA(atomic);

    numSamples = objectData->numSamples;
    if (objectData->flags & rtAMBOCCLMAPOBJECTVERTEXLIGHT)
    {
        /* Add on numVerts if we're doing vertex lighting */
        numSamples += RpGeometryGetNumVertices(RpAtomicGetGeometry(atomic));
    }

    RWRETURN(numSamples);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapLightingSessionGetNumSamples calculates the number of lighting
 * samples represented by the objects in a specified \ref RtAmbOcclMapLightingSession.
 *
 * This function traverses the objects specified by the received
 * \ref RtAmbOcclMapLightingSession structure. Only atomics flagged as rpATOMICRENDER
 * will be used. Note that the camera member of this structure is used.
 *
 * As with \ref RtAmbOcclMapIlluminate, this function fills in the totalSamples
 * member of the received lighting session. The value calculated is the same as
 * that calculated by \ref RtAmbOcclMapIlluminate. Both lightmap samples and vertex
 * lighting samples are taken into account. Camera frustum culling is done on
 * a per-object basis, hence there may be samples for which no lighting
 * calculations are actually done within \ref RtAmbOcclMapIlluminate (these are still
 * counted in tracking lighting progress, though - see also
 * \ref RtAmbOcclMapIlluminateProgressCallBack).
 *
 * Note that a returned value of zero does not indicate an error, merely that
 * no (visible) lighting samples were found in the supplied lighting session.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtAmbOcclMapLightingSession
 *
 * \return The number of lighting samples in the session on success, otherwise '-1'.
 *
 * \see RtAmbOcclMapAtomicGetNumSamples
 * \see RtAmbOcclMapIlluminate
 */
RwInt32
RtAmbOcclMapLightingSessionGetNumSamples(RtAmbOcclMapLightingSession *session)
{
    LtMapSessionInfo sessionInfo;
    AmbOcclMapObjectData *objectData;
    RwInt32 i, startObj, numObj, endObj;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapLightingSessionGetNumSamples"));

    /* Get local lists of sectors/atomics from the session
     * (culled w.r.t the incoming camera and object lists, if present) */
    _rtLtMapLightingSessionInfoCreate(&sessionInfo, session, TRUE);

    /* Count up how many samples in the session (-> % progress) */
    session->totalTriNVert = 0;
    session->totalSamples = 0;

    startObj = (RwInt32) session->startObj;
    numObj = 0;
    endObj = 0;

    if ((session->numObj == 0) || (numObj < (RwInt32) session->numObj))
    {
        startObj = session->startObj;
        if (startObj < 0)
            startObj = 0;

        if (session->numObj == 0)
        {
            endObj = sessionInfo.numAtomics;
        }
        else
        {
            endObj = startObj + (session->numObj - numObj);

            if (endObj > (RwInt32) sessionInfo.numAtomics)
                endObj = (RwInt32) sessionInfo.numAtomics;
        }

        numObj = endObj - startObj;

        for (i = startObj; i < (RwInt32) endObj; i++)
        {
            RpAtomic *atomic = *(RpAtomic **)rwSListGetEntry(sessionInfo.localAtomics, i);

            if (RpAtomicGetFlags(atomic) & rpATOMICRENDER)
            {
                objectData = RPAMBOCCLMAPATOMICGETDATA(atomic);

                session->totalSamples += RtAmbOcclMapAtomicGetNumSamples(atomic);

                if ((objectData->flags & rtAMBOCCLMAPOBJECTAMBOCCLMAP) ||
                    (objectData->flags & rtAMBOCCLMAPOBJECTVERTEXLIGHT))
                {
                    session->totalTriNVert += RpGeometryGetNumTriangles(RpAtomicGetGeometry(atomic));
                }
            }
        }
    }

    session->totalObj = sessionInfo.numAtomics;

    _rtLtMapLightingSessionInfoDestroy(&sessionInfo);

    RWRETURN(session->totalSamples);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapGetAmbOcclMapCounter is used to retrieve the counter used
 * to name lightmaps with sequentially increasing numeric suffices.
 *
 * See \ref RtAmbOcclMapSetAmbOcclMapCounter for further details.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \return The value of the global lightmap counter
 *
 * \see RtAmbOcclMapSetAmbOcclMapCounter
 * \see RtAmbOcclMapGetDefaultPrefixString
 * \see RtAmbOcclMapSetDefaultPrefixString
 * \see RpAmbOcclMapAtomicGetAmbOcclMap
 * \see RpAmbOcclMapAtomicSetAmbOcclMap
 */
RwUInt32
RtAmbOcclMapGetAmbOcclMapCounter(void)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapGetAmbOcclMapCounter"));

    RWRETURN(_rpAmbOcclMapGlobals.lightMapCount);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapSetAmbOcclMapCounter is used to modify the counter used
 * to name lightmaps with sequentially increasing numeric suffices.
 *
 * When lightmaps are created (see \ref RtAmbOcclMapAmbOcclMapsCreate), their
 * name is automatically generated by appending a counter value (incremented
 * by one for each new lightmap generated) to a global 'prefix' string.
 * For example, if the current prefix string is "ltmp", the fifth lightmap
 * to be created will be named "ltmp0005" (note that the string and number
 * are padded with zeroes to be 8 characters long).
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  value  The new value of the global lightmap counter
 *
 * \return TRUE on success, FALSE otherwise
 *
 * \see RtAmbOcclMapGetAmbOcclMapCounter
 * \see RtAmbOcclMapGetDefaultPrefixString
 * \see RtAmbOcclMapSetDefaultPrefixString
 * \see RpAmbOcclMapAtomicGetAmbOcclMap
 * \see RpAmbOcclMapAtomicSetAmbOcclMap
 */
RwBool
RtAmbOcclMapSetAmbOcclMapCounter(RwUInt32 value)
{
    RwUInt32 length, maxCount = 1;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapSetAmbOcclMapCounter"));

    /* Work out the max. allowable value given the current prefix string */
    length = 8 - rwstrlen(_rpAmbOcclMapGlobals.prefix);
    RWASSERT(length > 0);
    while (length--)
        maxCount *= 10;
    if (value >= maxCount)
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtAmbOcclMapSetAmbOcclMapCounter",
            "Count value too large");
        RWRETURN(FALSE);
    }

    _rpAmbOcclMapGlobals.lightMapCount = value;

    RWRETURN(TRUE);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapGetDefaultPrefixString is used to retrieve the default
 * string used to generate lightmap texture names.
 *
 * See \ref RtAmbOcclMapSetDefaultPrefixString for further details.
 *
 * \return A pointer to the current lightmap prefix string
 *
 * \see RtAmbOcclMapSetDefaultPrefixString
 * \see RtAmbOcclMapGetAmbOcclMapCounter
 * \see RtAmbOcclMapSetAmbOcclMapCounter
 * \see RpAmbOcclMapAtomicGetAmbOcclMap
 * \see RpAmbOcclMapAtomicSetAmbOcclMap
 */
const RwChar *
RtAmbOcclMapGetDefaultPrefixString(void)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapGetDefaultPrefixString"));

    RWRETURN(&(_rpAmbOcclMapGlobals.prefix[0]));
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapSetDefaultPrefixString is used to set the default
 * string used to generate lightmap texture names.
 *
 * When lightmaps are created (see \ref RtAmbOcclMapAmbOcclMapsCreate), their
 * name is automatically generated by appending a counter value (incremented
 * by one for each new lightmap generated) to a global 'prefix' string.
 * For example, if the current prefix string is "ltmp", the fifth lightmap
 * to be created will be named "ltmp0005" (note that the string and number
 * are padded with zeroes to be 8 characters long). Calling this function
 * resets the counter value to zero.
 *
 * By varying prefix strings, the user may avoid naming clashes between the
 * lightmaps in different worlds (if two worlds are to be resident in memory
 * simultaneously). Alternatively, lightmap texture names may be edited
 * directly (see \ref RpAmbOcclMapAtomicGetAmbOcclMap).
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  string  A pointer to a string from which to generate the names of
 *                 subsequently created lightmaps
 *
 * \return TRUE on success, FALSE otherwise
 *
 * \see RtAmbOcclMapGetDefaultPrefixString
 * \see RtAmbOcclMapGetAmbOcclMapCounter
 * \see RtAmbOcclMapSetAmbOcclMapCounter
 * \see RpAmbOcclMapAtomicGetAmbOcclMap
 * \see RpAmbOcclMapAtomicSetAmbOcclMap
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RwBool
RtAmbOcclMapSetDefaultPrefixString(RwChar *string)
{
    RwUInt32 length;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapSetDefaultPrefixString"));

    RWASSERT(NULL != string);

    length = rwstrlen(string);
    RWASSERT(length <= rpAMBOCCLMAPMAXPREFIXSTRINGLENGTH);
    if (length > rpAMBOCCLMAPMAXPREFIXSTRINGLENGTH)
    {
        RWRETURN(FALSE);
    }
    rwstrcpy(_rpAmbOcclMapGlobals.prefix, string);

    _rpAmbOcclMapGlobals.lightMapCount = 0;

    RWRETURN(TRUE);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapSetSliverAreaThreshold is used to set the threshold area
 * below which triangles are treated as slivers during lightmap
 * illumination.
 *
 * The calculation of normal vectors for triangles of a very small error
 * is subject to the numerical precision limitations of floating-point
 * numbers, hence triangles below a certain area are skipped during
 * lightmap illumination. The lightmap texels (if any) covered by
 * these triangles are filled in from neighboring triangles as a
 * post-process.
 *
 * This function allows to change the threshold area used, in case
 * certain user-created triangles happen to lie unfortunately on
 * the threshold. The symptom of a sliver triangle being lit which
 * should not be lit is usually that a line of lightmap texels on a
 * surface are assigned the incorrect color values (for example, if a
 * sliver has been determined to point in a strange direction, so the
 * lighting calculations may think it is pointing away from a light
 * whilst non-sliver triangles adjacent to it are pointing towards the
 * light). In such a case, increasing the sliver threshold value should
 * fix the problem.
 *
 * Note that increasing the threshold too far might make it impossible
 * for the post-process to accurately fill in all unprocessed lightmap
 * texels (resulting in uninitialized lightmap texels).
 *
 * The default sliver area threshold is given by the value of
 * rpAMBOCCLMAPDEFAULTSLIVERAREATHRESHOLD.
 *
 * This function should be called before a call to
 * \ref RtAmbOcclMapIlluminate in order to have any effect.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  threshold  The new sliver triangle area threshold to set
 *
 * \return  TRUE on success, otherwise FALSE
 *
 * \see RtAmbOcclMapIlluminate
 * \see RtAmbOcclMapGetSliverAreaThreshold
 * \see RtAmbOcclMapGetVertexWeldThreshold
 * \see RtAmbOcclMapSetVertexWeldThreshold
 */
RwBool
RtAmbOcclMapSetSliverAreaThreshold(RwReal threshold)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapSetSliverAreaThreshold"));

    RWASSERT(threshold >= 0);

    _rpAmbOcclMapGlobals.sliverAreaThreshold = threshold;

    RWRETURN(TRUE);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapGetSliverAreaThreshold is used to retrieve the current
 * threshold area below which triangles are treated as slivers during
 * lightmap illumination.
 *
 * The calculation of normal vectors for triangles of a very small error
 * is subject to the numerical precision limitations of floating-point
 * numbers, hence triangles below a certain area are skipped during
 * lightmap illumination. The lightmap texels (if any) covered by
 * these triangles are filled in from neighboring triangles as a
 * post-process.
 *
 * This function allows to retrieve the threshold area used, in case
 * certain user-created triangles happen to lie unfortunately on
 * the threshold. The symptom of a sliver triangle being lit which
 * should not be lit is usually that a line of lightmap texels on a
 * surface are assigned the incorrect color values (for example, if a
 * sliver has been determined to point in a strange direction, so the
 * lighting calculations may think it is pointing away from a light
 * whilst non-sliver triangles adjacent to it are pointing towards the
 * light). In such a case, increasing the sliver threshold value should
 * fix the problem (see \ref RtAmbOcclMapSetSliverAreaThreshold)
 *
 * Note that increasing the threshold too far might make it impossible
 * for the post-process to accurately fill in all unprocessed lightmap
 * texels (resulting in uninitialized lightmap texels).
 *
 * The default sliver area threshold is given by the value of
 * rpAMBOCCLMAPDEFAULTSLIVERAREATHRESHOLD.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \return  The current sliver area threshold value
 *
 * \see RtAmbOcclMapIlluminate
 * \see RtAmbOcclMapSetSliverAreaThreshold
 * \see RtAmbOcclMapGetVertexWeldThreshold
 * \see RtAmbOcclMapSetVertexWeldThreshold
 */
RwReal
RtAmbOcclMapGetSliverAreaThreshold(void)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapGetSliverAreaThreshold"));

    RWRETURN(_rpAmbOcclMapGlobals.sliverAreaThreshold);
}

RwBool
RtAmbOcclMapSetRayCount(RwUInt32 count)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapSetRayCount"));

    RWASSERT(count > 16);

    _rpAmbOcclMapGlobals.numRays = count;

    RWRETURN(TRUE);
}

RwUInt32
RtAmbOcclMapGetRayCount(void)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapGetRayCount"));

	RWRETURN(_rpAmbOcclMapGlobals.numRays);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapLightingSessionInitialize is used to initialize an
 * \ref RtAmbOcclMapLightingSession structure to a default form.
 *
 * This function sets the sessions' camera, atomicList, sectorList
 * and callback pointers to NULL. The startSample, numSamples and totalSamples
 * members are also set to zero. The session's world pointer is set up from a
 * parameter, since a session is not usable with a NULL world pointer.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtAmbOcclMapLightingSession structure to initialize
 * \param  world    A pointer to an \ref RpWorld for this session
 *
 * \return  A pointer to the initialized session on success, otherwise NULL
 *
 * \see RtAmbOcclMapLightingSessionDeInitialize
 * \see RtAmbOcclMapLightingSessionGetNumSamples
 * \see RtAmbOcclMapIlluminate
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapAmbOcclMapsClear
 * \see RtAmbOcclMapAmbOcclMapsDestroy
 * \see RtAmbOcclMapImagesPurge
 * \see RtAmbOcclMapTexDictionaryCreate
 */
RtAmbOcclMapLightingSession *
RtAmbOcclMapLightingSessionInitialize(RtAmbOcclMapLightingSession *session,
									  RpWorld *world)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapLightingSessionInitialize"));

    RWASSERT(NULL != session);
    RWASSERT(NULL != world);

    session->world            = world;                        /* Can't live wi'out this! */
    session->camera           = (RwCamera *)NULL;             /* Don't use a camera to cull lit objects */
    session->atomicList       = (RpAtomic **)NULL;            /* Light all atomics in the world */
    session->numAtomics       = 0;                            /* No atomics in the list */
    session->totalSamples     = 0;                            /* This gets filled by illuminate() */
    session->sampleCallBack   = RtAmbOcclMapDefaultSampleCallBack; /* The default sampleCallBack */
    session->visCallBack      = RtAmbOcclMapDefaultVisCallBack;    /* The default visCallBack */
    session->progressCallBack = NULL;                         /* No default progressCB */
    session->sampleMap        = NULL;                         /* No vismap created yet. */
    session->lightMapImg      = NULL;
    session->lightMap         = NULL;
    session->numTriNVert      = 0;
    session->totalTriNVert    = 0;
    session->invTotalTriNVert = 0;
    session->startObj         = 0;
    session->numObj           = 0;

    RWRETURN(session);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapLightingSessionDeInitialize is used to de-initialize a
 * \ref RtAmbOcclMapLightingSession structure to its default form by setting:
 *
 * \li The camera, atomicList, sectorList, world and callback pointers to NULL.
 * \li The startSample, numSamples and totalSamples members to zero.
 * \li Any temporary working memory free.
 *
 * To avoid memory leakage, call this function when a session is no longer
 * required.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtAmbOcclMapLightingSession structure to de-initialize
 *
 * \return  A pointer to the initialized session on success, otherwise NULL
 *
 * \see RtAmbOcclMapLightingSessionInitialize
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapAmbOcclMapsClear
 * \see RtAmbOcclMapAmbOcclMapsDestroy
 * \see RtAmbOcclMapImagesPurge
 */
RtAmbOcclMapLightingSession *
RtAmbOcclMapLightingSessionDeInitialize(RtAmbOcclMapLightingSession *session)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapLightingSessionDeInitialize"));
    RWASSERT(NULL != session);

    session->world            = NULL;                         /* Can't live wi'out this! */
    session->camera           = (RwCamera *)NULL;             /* Don't use a camera to cull lit objects */
    session->atomicList       = (RpAtomic **)NULL;            /* Light all atomics in the world */
    session->numAtomics       = 0;                            /* No atomics in the list */
    session->totalSamples     = 0;                            /* This gets filled by illuminate() */
    session->sampleCallBack   = RtAmbOcclMapDefaultSampleCallBack; /* The default sampleCallBack */
    session->visCallBack      = RtAmbOcclMapDefaultVisCallBack;    /* The default visCallBack */
    session->progressCallBack = NULL;                         /* No default progressCB */
    session->sampleMap        = NULL;                         /* No vismap created yet. */
    session->lightMapImg      = NULL;
    session->lightMap         = NULL;
    session->numTriNVert      = 0;
    session->totalTriNVert    = 0;
    session->invTotalTriNVert = 0;
    session->startObj         = 0;
    session->numObj           = 0;

    RWRETURN(session);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAtomicGetAmbOcclMapSize is used to retrieve the size of lightmap
 * to be created for a given atomic.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an atomic
 *
 * \return  The size of lightmap which will be (or has been) created for this atomic
 *
 * \see RtAmbOcclMapAtomicSetAmbOcclMapSize
 * \see RtAmbOcclMapAtomicGetFlags
 * \see RtAmbOcclMapAtomicSetFlags
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RwUInt32
RtAmbOcclMapAtomicGetAmbOcclMapSize(RpAtomic *atomic)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAtomicGetAmbOcclMapSize"));
    RWASSERT(NULL != atomic);

    if (RPAMBOCCLMAPATOMICGETDATA(atomic)->lightMapSize > 0)
    {
        RWRETURN(RPAMBOCCLMAPATOMICGETDATA(atomic)->lightMapSize);
    }
    else
    {
        RWRETURN(_rpAmbOcclMapGlobals.lightMapSize);
    }
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAtomicSetAmbOcclMapSize is used to set the size of lightmap to be
 * created for a given atomic.
 *
 * By default, the size of lightmap assigned to an object is determined by a
 * global default value (see \ref RtAmbOcclMapAmbOcclMapGetDefaultSize), but that
 * value may be overridden on a per-object basis by using this function.
 *
 * Note that you should only call this function before the atomic's lightmap
 * is created by \ref RtAmbOcclMapAmbOcclMapsCreate, for obvious reasons.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an atomic
 * \param  size    The new lightmap size for the atomic
 *
 * \return  A pointer to the atomic on success, otherwise NULL
 *
 * \see RtAmbOcclMapAtomicGetAmbOcclMapSize
 * \see RtAmbOcclMapAtomicGetFlags
 * \see RtAmbOcclMapAtomicSetFlags
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RpAtomic *
RtAmbOcclMapAtomicSetAmbOcclMapSize(RpAtomic *atomic, RwUInt32 size)
{
    AmbOcclMapObjectData *objectData;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAtomicSetAmbOcclMapSize"));

    /* Validate size */
    if (size < rpAMBOCCLMAPMINAMBOCCLMAPSIZE)
    {
        RWASSERT(size >= rpAMBOCCLMAPMINAMBOCCLMAPSIZE);
        RWRETURN((RpAtomic *)NULL);
    }
    
    if (size & (size - 1))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtAmbOcclMapAtomicSetAmbOcclMapSize",
                           "Lightmap size must be a power of two");
        RWRETURN((RpAtomic *)NULL);
    }

    objectData = RPAMBOCCLMAPATOMICGETDATA(atomic);
    RWASSERT(NULL == objectData->lightMap);
    /* We're cool */
    objectData->lightMapSize = size;

    RWRETURN(atomic);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAtomicGetFlags is used to retrieve lightmap-related flags
 * for a given atomic.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an atomic
 *
 * \return  The atomic's flags
 *
 * \see RtAmbOcclMapAtomicSetFlags
 * \see RtAmbOcclMapMaterialGetFlags
 * \see RtAmbOcclMapMaterialSetFlags
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RwUInt32
RtAmbOcclMapAtomicGetFlags(RpAtomic *atomic)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAtomicGetFlags"));
    RWASSERT(NULL != atomic);

    RWRETURN(RPAMBOCCLMAPATOMICGETDATA(atomic)->flags);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAtomicSetFlags is used to set lightmap-related flags
 * for a given atomic.
 *
 * Note that you cannot change the rtAMBOCCLMAPOBJECTAMBOCCLMAP flag for
 * an atomic after \ref RtAmbOcclMapAmbOcclMapsCreate has created a lightmap
 * for that atomic (see \ref RtAmbOcclMapObjectFlags).
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param atomic  A pointer to an atomic
 * \param flags   The new lightmap-related flags for this atomic
 *
 * \return  A pointer to the atomic on success, otherwise NULL
 *
 * \see RtAmbOcclMapAtomicGetFlags
 * \see RtAmbOcclMapMaterialGetFlags
 * \see RtAmbOcclMapMaterialSetFlags
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RpAtomic *
RtAmbOcclMapAtomicSetFlags(RpAtomic *atomic, RwUInt32 flags)
{
    AmbOcclMapObjectData *objectData;
    RpGeometry *geom;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAtomicSetFlags"));
    objectData = RPAMBOCCLMAPATOMICGETDATA(atomic);

    /* Validate flag changes */
    if ((NULL != objectData->lightMap) && (!(flags & rtAMBOCCLMAPOBJECTAMBOCCLMAP)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtAmbOcclMapAtomicSetFlags",
            "The rtAMBOCCLMAPOBJECTAMBOCCLMAP flag may not be changed whilst the atomic has a lightmap. Call RtAmbOcclMapAtomicAmbOcclMapDestroy first.");
        RWRETURN((RpAtomic *)NULL);
    }
    geom = RpAtomicGetGeometry(atomic);
    if ((flags & rtAMBOCCLMAPOBJECTVERTEXLIGHT) &&
        ((!(RpGeometryGetFlags(geom) & rpGEOMETRYNORMALS)) ||
         (!(RpGeometryGetFlags(geom) & rpGEOMETRYPRELIT))))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtAmbOcclMapAtomicSetFlags",
            "The rtAMBOCCLMAPOBJECTVERTEXLIGHT flag may not be set for objects without vertex normals and prelight colors.");
        RWRETURN((RpAtomic *)NULL);
    }

    /* We're cool */
    objectData->flags = flags;

    RWRETURN(atomic);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAmbOcclMapGetDefaultSize is used to retrieve the size of
 * lightmaps which will subsequently be created.
 *
 * The global default lightmap size value may be overridden on a per
 * object basis (see \ref RtAmbOcclMapAtomicSetAmbOcclMapSize).
 *
 * The default size of lightmaps on startup is given by the value
 * rpAMBOCCLMAPDEFAULTAMBOCCLMAPSIZE and can be overridden with this function.
 * Lightmaps are always square and must have sides a power of two in
 * length.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \return  The current default lightmap size
 *
 * \see RtAmbOcclMapAmbOcclMapSetDefaultSize
 * \see RtAmbOcclMapAtomicSetAmbOcclMapSize
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RwUInt32
RtAmbOcclMapAmbOcclMapGetDefaultSize(void)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAmbOcclMapGetDefaultSize"));
    RWASSERT(_rpAmbOcclMapGlobals.module.numInstances > 0);

    RWRETURN(_rpAmbOcclMapGlobals.lightMapSize);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAmbOcclMapSetDefaultSize specifies the size of lightmaps
 * which will subsequently be created.
 *
 * The global default lightmap size value may be overridden on a per
 * object basis (see \ref RtAmbOcclMapAtomicSetAmbOcclMapSize).
 *
 * The default size of lightmaps on startup is given by the value
 * rpAMBOCCLMAPDEFAULTAMBOCCLMAPSIZE and can be overridden with this function.
 * Lightmaps are always square and must have sides a power of two in
 * length.
 *
 * This function should be called before \ref RtAmbOcclMapAmbOcclMapsCreate
 * if it is to have any effect.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  size  The size of subsequently-created lightmaps
 *
 * \return  TRUE on success, otherwise FALSE
 *
 * \see RtAmbOcclMapAmbOcclMapGetDefaultSize
 * \see RtAmbOcclMapAtomicSetAmbOcclMapSize
 * \see RtAmbOcclMapAmbOcclMapsCreate
 */
RwBool
RtAmbOcclMapAmbOcclMapSetDefaultSize(RwUInt32 size)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAmbOcclMapSetDefaultSize"));
    RWASSERT(0 < _rpAmbOcclMapGlobals.module.numInstances);

    /* Validate size */
    if (size < rpAMBOCCLMAPMINAMBOCCLMAPSIZE)
    {
        RWASSERT(size >= rpAMBOCCLMAPMINAMBOCCLMAPSIZE);
    }

    if (size & (size - 1))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtAmbOcclMapAmbOcclMapSetDefaultSize",
                           "Lightmap size must be a power of two");
        RWRETURN(FALSE);
    }

    /* We're cool */
    _rpAmbOcclMapGlobals.lightMapSize = size;

    RWRETURN(TRUE);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapSetVertexWeldThreshold is used to set the threshold distance
 * below which triangle vertices are treated as being at the same position
 * during lightmap UV calculation.
 *
 * The calculation of per-vertex lightmap UV coordinates, during
 * \ref RtAmbOcclMapAmbOcclMapsCreate, makes the assumption that adjacent
 * triangles which have different vertices, but whose vertices share
 * the same position, should be grouped together (and thus be adjacent
 * in) the lightmap of the current object. This means that lightmap
 * texels will be shared across the two triangles.
 *
 * The vertex welding threshold distance is used to determin whether two
 * vertices are at the same position. The distance used should be the
 * same as that used during the export of objects from the user's
 * modelling package. If the threshold is too large, then triangles will
 * be inappropriately grouped, which could cause artifacts during
 * lightmap illumination. If the threshold is too large, then more
 * triangles will be split up than necessary in the object's lightmap,
 * resulting in less efficient use of the lightmap's texels.
 *
 * The default vertex welding threshold distance is given by the value
 * of rpAMBOCCLMAPDEFAULTVERTEXWELDTHRESHOLD.
 *
 * This function should be called before a call to
 * \ref RtAmbOcclMapAmbOcclMapsCreate in order to have any effect.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  threshold  The new vertex-welding threshold to set
 *
 * \return  TRUE on success, otherwise FALSE
 *
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapGetSliverAreaThreshold
 * \see RtAmbOcclMapSetSliverAreaThreshold
 * \see RtAmbOcclMapGetVertexWeldThreshold
 */
RwBool
RtAmbOcclMapSetVertexWeldThreshold(RwReal threshold)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapSetVertexWeldThreshold"));

    RWASSERT(threshold >= 0);

    _rpAmbOcclMapGlobals.vertexWeldThreshold = threshold;

    RWRETURN(TRUE);
}


/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapGetVertexWeldThreshold is used to retrieve the current
 * threshold distance below which triangle vertices are treated as being
 * at the same position during lightmap UV calculation.
 *
 * The calculation of per-vertex lightmap UV coordinates, during
 * \ref RtLtMapLightMapsCreate, makes the assumption that adjacent
 * triangles which have different vertices, but whose vertices share
 * the same position, should be grouped together (and thus be adjacent
 * in) the lightmap of the current object. This means that lightmap
 * texels will be shared across the two triangles.
 *
 * The vertex welding threshold distance is used to determin whether two
 * vertices are at the same position. The distance used should be the
 * same as that used during the export of objects from the user's
 * modelling package. If the threshold is too large, then triangles will
 * be inappropriately grouped, which could cause artifacts during
 * lightmap illumination. If the threshold is too large, then more
 * triangles will be split up than necessary in the object's lightmap,
 * resulting in less efficient use of the lightmap's texels.
 *
 * The default vertex welding threshold distance is given by the value
 * of rpAMBOCCLMAPDEFAULTVERTEXWELDTHRESHOLD.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \return  The current vertex welding threshold distane
 *
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapGetSliverAreaThreshold
 * \see RtAmbOcclMapSetSliverAreaThreshold
 * \see RtAmbOcclMapSetVertexWeldThreshold
 */
RwReal
RtAmbOcclMapGetVertexWeldThreshold(void)
{
    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapGetVertexWeldThreshold"));

    RWRETURN(_rpAmbOcclMapGlobals.vertexWeldThreshold);
}

//@{ Jaewon 20050105
// allocate & sign uvs only(do not create maps).
RtAmbOcclMapLightingSession *
RtAmbOcclMapAmbOcclMapsCreateUVsOnly(RtAmbOcclMapLightingSession *session,
									 RwReal density)
{
    LtMapSessionInfo sessionInfo;
    AmbOcclMapObjectData *objectData;
    AmbOcclMapWorldData  *worldData;
    LtMapAllocUVData allocUVData;
    RwUInt32 i;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAmbOcclMapsCreateUVsOnly"));
    RWASSERT(_rpAmbOcclMapGlobals.module.numInstances > 0);
    RWASSERT(density > 0);

    RWASSERT(NULL != session);
    RWASSERT(NULL != session->world);

    /* If lightmaps exist already, purge them */
    RtAmbOcclMapAmbOcclMapsDestroy(session);

    /* Create the Slist */
    RWASSERT (rtLtMapGlobals.ltMapSlots == NULL);
    rtLtMapGlobals.ltMapSlots = _rwSListCreate(sizeof(LtMapSlot),
        rwID_AMBOCCLMAPPLUGIN | rwMEMHINTDUR_EVENT);

    /* Get local lists of sectors/atomics from the session
     * (culled w.r.t the incoming camera and object lists, if present) */
    _rtLtMapLightingSessionInfoCreate(&sessionInfo, session, TRUE);

    /* This gets multiplied by global and per-material
     * lightmap and arealight sample density modifiers */
    worldData = RPAMBOCCLMAPWORLDGETDATA(session->world);
    worldData->lightMapDensity = density;
    worldData->flag |= rpAMBOCCLMAPWORLDFLAGAMBOCCLMAP;

    /* We store lightmaps in gLtMapSlots[] during building */
    allocUVData.world   = session->world;
    allocUVData.slots = NULL;

    /* LtMapAtomicAllocateUV sets up the appropriate render pipelines */
    for (i = 0;i < (RwUInt32)sessionInfo.numAtomics;i++)
    {
        RpAtomic *atomic = *(RpAtomic **)rwSListGetEntry(sessionInfo.localAtomics, i);
        RpGeometry *geom = RpAtomicGetGeometry(atomic);
        objectData = RPAMBOCCLMAPATOMICGETDATA(atomic);

        /* Only lightmap atomics flagged with rpATOMICRENDER and
         * rtAMBOCCLMAPOBJECTAMBOCCLMAP (also, paranoidly check for empty atomics). */
        if ((RpAtomicGetFlags(atomic) & rpATOMICRENDER) &&
            (objectData->flags & rtAMBOCCLMAPOBJECTAMBOCCLMAP) &&
            (RpGeometryGetNumTriangles(geom) > 0) )
        {
            _rtLtMapAtomicAllocateUV(session, atomic, &allocUVData, TRUE);
        }

        objectData->clearCol = FALSE;
    }

    /* Probably a good idea, given we're changing
     * pipelines and modifying UV data. */
    RwResourcesEmptyArena();

    _rtLtMapLightingSessionInfoDestroy(&sessionInfo);

    _rwSListEmpty(rtLtMapGlobals.ltMapSlots);
    _rwSListDestroy(rtLtMapGlobals.ltMapSlots);
    rtLtMapGlobals.ltMapSlots = NULL;

    RWRETURN(session);
}
//@} Jaewon
/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAmbOcclMapsCreate creates lightmaps for the objects specified within
 * an \ref RtAmbOcclMapLightingSession.
 *
 * This function traverses the objects specified by the received
 * \ref RtAmbOcclMapLightingSession structure. Only atomics flagged as rpATOMICRENDER
 * will be used. Note that the camera member of this structure is used.
 *
 * Any given atomic or world sector may reference at most one lightmap. A single
 * lightmap may, however, be referenced by multiple such objects. Note that this
 * lightmap 'sharing' will only occur between the objects specified within the
 * received \ref RtAmbOcclMapLightingSession. Hence, if objects are passed to this
 * function one by one, no lightmap sharing will occur.
 *
 * In creating a lightmap for a given object, each triangle in the object must
 * be placed within the lightmap (i.e have its second set of UV coordinates set
 * up). This process is fairly complex and slow, due to two considerations.
 * Firstly, to minimize the usage of video memory by lightmaps, object triangles
 * must be packed into lightmaps as tightly as possible - this is a variant of
 * the 'knapsack problem', which is non-trivial. Secondly, this implementation
 * of lightmaps is designed to work with tristripped geometry, for efficiency
 * (most lightmap implementations require trilist geometry as it simplifies
 * many aspects of lightmap generation, such as this one, greatly). This requires
 * analysing surface topology and taking several precautions to avoid visual
 * artifacts, but the result is that fewer lightmap texels are consumed per
 * triangle (since adjacent triangles can share lightmap texels) and that
 * lightmapped geometry renders much more quickly (especially on platforms such
 * as PlayStation 2).
 *
 * Lightmap UV coordinates are calculated such as to distribute lighting sample
 * points (lightmap texels) uniformly over geometry, at a density (in world-
 * space) specified by the density parameter of this function. This density may
 * be modified on a per-material basis (see
 * \ref RtAmbOcclMapMaterialSetAmbOcclMapDensityModifier).
 *
 * If, given the specified lightmap density, a particular sector or atomic
 * contains triangles of too great an area to fit into a single lightmap, the
 * lightmap density of those triangles is halved. This is repeated until the
 * triangles fit or the process fails. Hence, it is recommended to choose
 * lightmap density and object size (e.g by controlling BSP sectorization)
 * such that this shrinkage need not occur (a rough rule of thumb is to ensure
 * that "density*objectSize < lightMapSize"). Debug stream messages will be
 * issued if it does.
 *
 * The size of lightmap assigned to each object is determined by a global
 * value (see \ref RtAmbOcclMapAmbOcclMapSetDefaultSize), which may be overridden
 * on a per-object basis (see \ref RtAmbOcclMapAtomicSetAmbOcclMapSize).
 *
 * Lightmaps are named automatically (see \ref RtAmbOcclMapGetDefaultPrefixString)
 * but they may be renamed (see \ref RpAmbOcclMapAtomicSetAmbOcclMap) and/or
 * otherwise modified before they are saved to disk. Lightmaps automatically
 * get added to the current texture dictionary on creation.
 *
 * By default, this function will initialize lightmap colors to a black and
 * white checkerboard. If the color parameter is non-NULL, lightmaps will be
 * cleared to this color instead (note that the alpha channel is set to an
 * internally-used value in all cases).
 *
 * In addition to creating lightmaps, this function also changes the
 * object pipelines of the affected sectors and atomics, setting them to
 * use platform-specific lightmap rendering pipelines.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtAmbOcclMapLightingSession
 * \param  density  A \ref RwReal specifying the number of lightmap texels
 *                  per unit worldspace
 * \param  color    An optional pointer to an \ref RwRGBA specifying the
 *                  color to which to clear the new lightmaps
 *
 * \return  A pointer to the lighting session on success, otherwise NULL
 *
 * \see RtAmbOcclMapAmbOcclMapsDestroy
 * \see RtAmbOcclMapAmbOcclMapsClear
 * \see RtAmbOcclMapMaterialGetAmbOcclMapDensityModifier
 * \see RtAmbOcclMapMaterialSetAmbOcclMapDensityModifier
 * \see RtAmbOcclMapAmbOcclMapSetDefaultSize
 * \see RtAmbOcclMapAtomicSetAmbOcclMapSize
 * \see RtAmbOcclMapGetDefaultPrefixString
 * \see RtAmbOcclMapSetDefaultPrefixString
 * \see RpAmbOcclMapAtomicGetAmbOcclMap
 * \see RpAmbOcclMapAtomicSetAmbOcclMap
 * \see RtAmbOcclMapGetVertexWeldThreshold
 * \see RtAmbOcclMapSetVertexWeldThreshold
 */
RtAmbOcclMapLightingSession *
RtAmbOcclMapAmbOcclMapsCreate(RtAmbOcclMapLightingSession *session,
							  RwReal density,
							  RwRGBA *color)
{
    LtMapSessionInfo sessionInfo;
    AmbOcclMapObjectData *objectData;
    AmbOcclMapWorldData  *worldData;
    LtMapAllocUVData allocUVData;
    RwUInt32 i;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAmbOcclMapsCreate"));
    RWASSERT(_rpAmbOcclMapGlobals.module.numInstances > 0);
    RWASSERT(density > 0);

    RWASSERT(NULL != session);
    RWASSERT(NULL != session->world);

    /* If lightmaps exist already, purge them */
    RtAmbOcclMapAmbOcclMapsDestroy(session);

    /* Create the Slist */
    RWASSERT (rtLtMapGlobals.ltMapSlots == NULL);
    rtLtMapGlobals.ltMapSlots = _rwSListCreate(sizeof(LtMapSlot),
        rwID_AMBOCCLMAPPLUGIN | rwMEMHINTDUR_EVENT);

    /* Get local lists of sectors/atomics from the session
     * (culled w.r.t the incoming camera and object lists, if present) */
    _rtLtMapLightingSessionInfoCreate(&sessionInfo, session, TRUE);

    /* This gets multiplied by global and per-material
     * lightmap and arealight sample density modifiers */
    worldData = RPAMBOCCLMAPWORLDGETDATA(session->world);
    worldData->lightMapDensity = density;
    worldData->flag |= rpAMBOCCLMAPWORLDFLAGAMBOCCLMAP;

    /* We store lightmaps in gLtMapSlots[] during building */
    allocUVData.world   = session->world;
    allocUVData.slots = NULL;

    /* LtMapAtomicAllocateUV sets up the appropriate render pipelines */
    for (i = 0;i < (RwUInt32)sessionInfo.numAtomics;i++)
    {
        RpAtomic *atomic = *(RpAtomic **)rwSListGetEntry(sessionInfo.localAtomics, i);
        RpGeometry *geom = RpAtomicGetGeometry(atomic);
        objectData = RPAMBOCCLMAPATOMICGETDATA(atomic);

        /* Only lightmap atomics flagged with rpATOMICRENDER and
         * rtAMBOCCLMAPOBJECTAMBOCCLMAP (also, paranoidly check for empty atomics). */
        if ((RpAtomicGetFlags(atomic) & rpATOMICRENDER) &&
            (objectData->flags & rtAMBOCCLMAPOBJECTAMBOCCLMAP) &&
            (RpGeometryGetNumTriangles(geom) > 0) )
        {
			//@{ Jaewon 20050105
			// createUVsOnly
            _rtLtMapAtomicAllocateUV(session, atomic, &allocUVData, FALSE);
			//@} Jaewon
        }

        /* Record the color */
        if (NULL != color)
        {
            objectData->clearCol = TRUE;
            objectData->color = *color;
        }
        else
        {
            objectData->clearCol = FALSE;
        }
    }

#ifdef SHOWLIGHTMAPUSAGE
    {
        RwUInt32            numSlots;

        /* Complete colouring in lightmaps to clearly show usage */

        numSlots = _rwSListGetNumEntries(rtLtMapGlobals.ltMapSlots);

        for (i = 0;i < numSlots;i++)
        {
            static RwChar string[256];
            RwUInt32  numUsed = 0, numWasted = 0, numUnInit = 0;
            RwRaster *raster = RwTextureGetRaster(allocUVData.slots[i].lightMap);
            RwUInt32  width, height, stride;
            RwImage  *image;
            RwUInt8  *pixels;
            RwUInt32 j, x, y;

            for (j = 0;j < allocUVData.slots[i].count;j++)
            {
                /* Fill free space with a random bright green */
                RwRGBA unUsedColour = {0, 128, 0, 255};
                unUsedColour.green += 127 & RpRandom();
                RasterRectClear(raster, &(allocUVData.slots[i].rects[j]), unUsedColour);
            }

            /* Work out usage/wastage
            * Red is wasted space
            * Green is free space
            * Yellow is used space
            * Blue is uninitialised space (shouldn't see this) */
            width  = RwRasterGetWidth( raster);
            height = RwRasterGetHeight(raster);
            image = RwImageCreate(width, height, 32);
            RWASSERT(NULL != image);

            RwImageAllocatePixels(image);
            RwImageSetFromRaster(image, raster);
            stride = RwImageGetStride(image);
            pixels = RwImageGetPixels(image);
            for (y = 0;y < height;y++)
            {
                RwRGBA *col = (RwRGBA *)&(pixels[y * stride]);
                for (x = 0;x < width;x++)
                {
                    RwInt32 redMinusGreen;
                    redMinusGreen = (RwInt32)col->red - (RwInt32)col->green;
                    if  (redMinusGreen >= 128)
                    {
                        numWasted++; /* Red, wasted space */
                    }
                    else if (redMinusGreen > -128)
                    {
                        numUsed++; /* Yellow, used space */
                    }
                    if (col->blue)
                        numUnInit++;
                    col++;
                }
            }
            RWASSERT(0 == numUnInit);
            rwsprintf(string, "[lightmap %d] Used: %.1f%%  Wasted: %.1f%%",
                    i, 100 * (numUsed   / (RwReal)(width*height)),
                       100 * (numWasted / (RwReal)(width*height)));
            RwDebugSendMessage(
                rwDEBUGMESSAGE, "RtAmbOcclMapAmbOcclMapsCreate", string);
            RwImageDestroy(image);

            /* We turned auto-mipmapping off in RasterRectClear(),
            * so we have to reinstate it now and update mipmaps */
            if (RpAmbOcclMapGetRasterFormat() & rwRASTERFORMATAUTOMIPMAP)
            {
                RWASSERT((RwUInt32)RwRasterGetFormat(raster) ==
                    ((RpAmbOcclMapGetRasterFormat() & rwRASTERFORMATMASK) &
                    (~rwRASTERFORMATAUTOMIPMAP)) );
                /* Naughty but hey... */
                raster->cFormat |= rwRASTERFORMATAUTOMIPMAP >> 8;
                RwRasterLock(raster, 0, rwRASTERLOCKREADWRITE);
                RwRasterUnlock(raster);
            }
        }
    }

#else

    /* Clear the lightmaps to a visibly recognisable state
     * (this will create the images too, also in a cleared state) */
    RtAmbOcclMapAmbOcclMapsClear(session, color);

#endif /* def SHOWLIGHTMAPUSAGE */

    /* Probably a good idea, given we're changing
     * pipelines and modifying UV data. */
    RwResourcesEmptyArena();

    _rtLtMapLightingSessionInfoDestroy(&sessionInfo);

    for (i = 0; i < (RwUInt32) _rwSListGetNumEntries (rtLtMapGlobals.ltMapSlots); i++)
    {
        /* The sample maps and light maps should not be destroyed
         * by this, as the atomics and world sectors still
         * have references to them */
        _rpLtMapSampleMapDestroy (allocUVData.slots [i].sampleMap);
        RwTextureDestroy         (allocUVData.slots [i].lightMap );
		allocUVData.slots [i].lightMap = NULL;
    }
    _rwSListEmpty(rtLtMapGlobals.ltMapSlots);
    _rwSListDestroy(rtLtMapGlobals.ltMapSlots);
    rtLtMapGlobals.ltMapSlots = NULL;

    RWRETURN(session);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAtomicAmbOcclMapDestroy destroys the lightmap (if any)
 * associated with a given atomic.
 *
 * Note that this function destroys the intermediate sample map attached
 * to the object, if it exists. Hence it is not necessary
 * to call \ref RtAmbOcclMapAtomicImagePurge before calling this function.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an \ref RpAtomic
 *
 * \return  A pointer to the atomic on success, otherwise NULL
 *
 * \see RtAmbOcclMapAmbOcclMapsDestroy
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapAmbOcclMapsClear
 * \see RpAmbOcclMapAtomicGetAmbOcclMap
 * \see RpAmbOcclMapAtomicSetAmbOcclMap
 */
RpAtomic *
RtAmbOcclMapAtomicAmbOcclMapDestroy(RpAtomic *atomic)
{
    AmbOcclMapObjectData *objectData;
    AmbOcclMapGeometryData *geometryData;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAtomicAmbOcclMapDestroy"));

    RWASSERT(NULL != atomic);
    objectData = RPAMBOCCLMAPATOMICGETDATA(atomic);

    /* Destroy the lightmap and image if present */
    if (NULL != objectData->lightMap)
    {
        RwTextureDestroy(objectData->lightMap);
        objectData->lightMap = (RwTexture *)NULL;
        /* It initialised when lightmaps are created, ergo clear the value here */
        objectData->numSamples = 0;
        /* It's no longer lightmapped, ergo reset it to use the default pipeline */
		//@{ Jaewon 20041215
		// turn off the matd3dfx.
		RpAtomicFxDisable(atomic);
		// release matd3dfx resources.
		RpAtomicFxRelease(atomic);
		//@} Jaewon
        RpAtomicSetPipeline(atomic, (RxPipeline *)NULL);
    }

    if (NULL != objectData->sampleMap)
    {
        _rpLtMapSampleMapDestroy(objectData->sampleMap);
    }

    /* Destroy the PolySet array associated with the geometry */
    geometryData = RPAMBOCCLMAPGEOMETRYGETDATA (RpAtomicGetGeometry (atomic));
    if (geometryData->PolySetArray != NULL)
    {
        RwInt32 j;

        /* Reset the UV2s so that LightMapsCreate() will work again */
        /* TODO[2][AAO]: REALLY NEED A FLAG PER-ATOMIC/SECTOR THAT SAYS "UNINITIALISED"
         *               SO YOU KNOW WHAT STATE THE UVS ARE IN... */
        _rtLtMapGeometryResetUVs (RpAtomicGetGeometry (atomic));

        /* Release the polysets */
        for (j = 0; j < geometryData->numSets; j++)
        {
            rwSListDestroy(geometryData->PolySetArray [j].members);
        }
        
        RwFree (geometryData->PolySetArray);
        geometryData->PolySetArray = NULL;
    }

    objectData->sampleMap = NULL;

    RWRETURN(atomic);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAmbOcclMapsDestroy destroys the lightmaps (if any)
 * associated with the objects in an \ref RtAmbOcclMapLightingSession.
 *
 * This function traverses the objects specified by the received
 * \ref RtAmbOcclMapLightingSession structure. Only atomics flagged as
 * rpATOMICRENDER will be used. Note that the camera member of this
 * structure is used.
 *
 * Note that this function destroys the intermediate sample map attached
 * to the objects, if they exist. Hence it is not necessary
 * to call \ref RtAmbOcclMapImagesPurge before calling this function.
 *
 * The matd3dfx plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtAmbOcclMapLightingSession
 *
 * \return  A pointer to the session on success, otherwise NULL
 *
 * \see RtAmbOcclMapAtomicAmbOcclMapDestroy
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapAmbOcclMapsClear
 * \see RpAmbOcclMapAtomicGetAmbOcclMap
 * \see RpAmbOcclMapAtomicSetAmbOcclMap
 */
void
RtAmbOcclMapAmbOcclMapsDestroy(RtAmbOcclMapLightingSession *session)
{
    LtMapSessionInfo sessionInfo;
    AmbOcclMapWorldData  *worldData;
    RwUInt32 i;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAmbOcclMapsDestroy"));

    RWASSERT(NULL != session);
    RWASSERT(NULL != session->world);

    /* Get local lists of sectors/atomics from the session
     * (culled w.r.t the incoming camera and object lists, if present) */
    _rtLtMapLightingSessionInfoCreate(&sessionInfo, session, TRUE);

    for (i = 0;i < (RwUInt32)sessionInfo.numAtomics;i++)
    {
        RpAtomic *atomic = *(RpAtomic **)rwSListGetEntry(sessionInfo.localAtomics, i);

        if (RpAtomicGetFlags(atomic) & rpATOMICRENDER)
        {
            /* This will reset UV2s to the axis-representative
             * values so that LightMapsCreate() will work again
             * and it also resets to the default pipeline */
            RtAmbOcclMapAtomicAmbOcclMapDestroy(atomic);
        }
    }

    _rtLtMapLightingSessionInfoDestroy(&sessionInfo);


    if (NULL != rtLtMapGlobals.ltMapSlots)
    {
        _rwSListEmpty(rtLtMapGlobals.ltMapSlots);

        _rwSListDestroy(rtLtMapGlobals.ltMapSlots);
    }

    rtLtMapGlobals.ltMapSlots = NULL;

    /* This gets multiplied by global and per-material
     * lightmap and arealight sample density modifiers */
    worldData = RPAMBOCCLMAPWORLDGETDATA(session->world);
    worldData->flag &= ~rpAMBOCCLMAPWORLDFLAGAMBOCCLMAP;

    RWRETURNVOID();
}

/*
 ****************************************************************************
 */
static RwReal
LtMapCalculateCumulateArea (RwV3d *vtx, RpTriangle *triangles,
                            RwUInt32 numTriangles, RpMaterialList *matList, RwUInt32 matListBase)
{
    RwReal cumulatedArea = 0.0f;
    RwUInt32 i;
    RwReal density;
    RpMaterial *mat;

    RWFUNCTION (RWSTRING ("LtMapCalculateCumulateArea"));

    for(i=0;i<numTriangles;i++)
    {
        RwV3d impT[3];
        RwV3d e01, e12;
        RwReal area;
        RwV3d cross;

        /* Get the vertices for the triangle corners */
        RwV3dAssign(&impT[0],&vtx[triangles [i].vertIndex[0]]);
        RwV3dAssign(&impT[1],&vtx[triangles [i].vertIndex[1]]);
        RwV3dAssign(&impT[2],&vtx[triangles [i].vertIndex[2]]);

        /* Calculate edges 01 & 12 */
        RwV3dSub(&e01,&impT[0],&impT[1]);
        RwV3dSub(&e12,&impT[1],&impT[2]);

        /* area = |01 x 12| / 2 */
        RwV3dCrossProduct (&cross, &e01, &e12);
        area = RwV3dLength (&cross) / 2.0f;

        /* Obtain material density */
        mat = rpMaterialListGetMaterial (matList, triangles [i].matIndex + matListBase);
        density = RtAmbOcclMapMaterialGetAmbOcclMapDensityModifier (mat);

        /* The lightmapping algorithm drops non-lightmapped materials
         * down to 1/16 the original density to save space.  I think
         * this means that they're still lightmapped. */
        if (!(RtAmbOcclMapMaterialGetFlags(mat) & rtAMBOCCLMAPMATERIALAMBOCCLMAP))
        {
            /* Reduce density ridiculously for non-lightmapped geom,
             * so we don't waste lightmap space on it */
            density *= 0.0625f; /* =1/16 */
        }

        /* Scale area according to material density */
        area *= (density * density);

        cumulatedArea += area;
    }

    RWRETURN (cumulatedArea);
}

/**
 * \ingroup rtambocclmap
 * \ref RtAmbOcclMapAtomicCalculateDensity will generate a global density for an
 * atomic.
 *
 * The returned value can then be passed to \ref RtAmbOcclMapAmbOcclMapsCreate.
 *
 * Although RtAmbOcclMapAtomicCalculateDensity usually gives correct results, if
 * density problems occur, scale down the value returned
 * by \ref RtAmbOcclMapAtomicCalculateDensity until expected
 * results are achieved.
 *
 * The default lightmap size needs to be set before calling this function
 * (\ref RtAmbOcclMapAmbOcclMapSetDefaultSize).
 *
 * \param  atomic    A pointer to the \ref RpAtomic
 *
 * \return The calculated density
 *
 * \see RtAmbOcclMapAmbOcclMapsCreate
 * \see RtAmbOcclMapAmbOcclMapSetDefaultSize
 */
RwReal
RtAmbOcclMapAtomicCalculateDensity(RpAtomic *atomic)
{
    RpGeometry *geom;
    RwReal density = 1.0f;
    RwUInt32 numTriangles;
    RpMorphTarget *morphTarget;
    RpTriangle *triangles;
    RwV3d *vtx;
    RwReal area;
    RwReal cumulatedArea;

    RWAPIFUNCTION(RWSTRING("RtAmbOcclMapAtomicCalculateDensity"));
    RWASSERT(atomic);
    geom = RpAtomicGetGeometry(atomic);
    RWASSERT(geom);

    /* If vertex lighting is off, density is zero */
    if (!(RtAmbOcclMapAtomicGetFlags(atomic) & rtAMBOCCLMAPOBJECTAMBOCCLMAP))
        RWRETURN (0.0f);

    numTriangles = RpGeometryGetNumTriangles(geom);
    if (numTriangles == 0)
        return density;

    morphTarget = RpGeometryGetMorphTarget(geom, 0);
    triangles   = RpGeometryGetTriangles  (geom);
    RWASSERT(morphTarget);
    RWASSERT(triangles);

    vtx = RpMorphTargetGetVertices(morphTarget);
    RWASSERT(vtx);

    cumulatedArea = LtMapCalculateCumulateArea (vtx, triangles, numTriangles, &(geom->matList), 0);

    rwSqrt(&area,cumulatedArea);

    if( area > 0.0f )
    {
        density = (RwReal)RtAmbOcclMapAmbOcclMapGetDefaultSize()/area * DENSITY_FUDGE_FACTOR;
    }

    RWRETURN(density);
}

/*===========================================================================*
 *--- Plugin functions ------------------------------------------------------*
 *===========================================================================*/

#define RPAMBOCCLMAPSAMPLEMAPSIZE(_x, _y) \
    ((((_x) * (_y)) + 0x07) >> 0x03)

rpLtMapSampleMap *
_rpAmbOcclMapSampleMapCreate( RwUInt32 w, RwUInt32 h )
{
    rpLtMapSampleMap      *sampleMap;
    RwUInt32            size;

    RWFUNCTION(RWSTRING("_rpAmbOcclMapSampleMapCreate"));

    RWASSERT(w > 0);
    RWASSERT(h > 0);

    size = sizeof(rpLtMapSampleMap);
    size += RPAMBOCCLMAPSAMPLEMAPSIZE(w, h);

    sampleMap = (rpLtMapSampleMap *) RwMalloc(size,
        rwID_AMBOCCLMAPPLUGIN | rwMEMHINTDUR_EVENT);
    if (NULL != sampleMap)
    {
        sampleMap->samplePixels = (RwUInt8 *)
            (((RwChar *) sampleMap) + sizeof(rpLtMapSampleMap));

        sampleMap->refCount = 1;

        memset(sampleMap->samplePixels, 0, (size - sizeof(rpLtMapSampleMap)));
    }

    RWRETURN(sampleMap);
}

RwBool
_rpAmbOcclMapSampleMapDestroy( rpLtMapSampleMap *sampleMap )
{
    RWFUNCTION(RWSTRING("_rpAmbOcclMapSampleMapDestroy"));

    RWASSERT(sampleMap);
    RWASSERT(sampleMap->refCount > 0);

    --sampleMap->refCount;
    if (sampleMap->refCount == 0)
    {
        RwFree(sampleMap);
    }

    RWRETURN(TRUE);
}

static void *
AmbOcclMapClose(void *instance,
                RwInt32 offset,
                RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapClose"));
    RWASSERT(NULL != instance);
    RWASSERT(0 < _rpAmbOcclMapGlobals.module.numInstances);

    /* One less module instance */
    _rpAmbOcclMapGlobals.module.numInstances--;

    if(0 == _rpAmbOcclMapGlobals.module.numInstances)
    {
    }

    RWRETURN(instance);
}

static void *
AmbOcclMapOpen(void *instance,
               RwInt32 offset,
               RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapOpen"));
    RWASSERT(NULL != instance);

    if(_rpAmbOcclMapGlobals.module.numInstances == 0)
    {
    }

    /* Set up default state */
    _rpAmbOcclMapGlobals.lightMapSize = rpAMBOCCLMAPDEFAULTAMBOCCLMAPSIZE;
    _rpAmbOcclMapGlobals.renderStyle  = rpAMBOCCLMAPSTYLERENDERBASE |
										rpAMBOCCLMAPSTYLERENDERAMBOCCLMAP;
    rwsprintf(_rpAmbOcclMapGlobals.prefix, rpAmbOcclMapDefaultPrefixString);
    RWASSERT(rwstrlen(RWSTRING("")) <= rpAMBOCCLMAPMAXPREFIXSTRINGLENGTH);
    _rpAmbOcclMapGlobals.lightMapCount           = 0;
    _rpAmbOcclMapGlobals.sliverAreaThreshold     = rpAMBOCCLMAPDEFAULTSLIVERAREATHRESHOLD;
    _rpAmbOcclMapGlobals.vertexWeldThreshold     = rpAMBOCCLMAPDEFAULTVERTEXWELDTHRESHOLD;
	_rpAmbOcclMapGlobals.numRays = rpAMBOCCLMAPDEFAULTRAYCOUNT;

    /* Another instance */
    _rpAmbOcclMapGlobals.module.numInstances++;

    RWRETURN(instance);
}

static void *
AmbOcclMapAtomicConstructor(void *object,
							RwInt32 offset,
							RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapAtomicConstructor"));

    /* By default it may be lightmapped, will not be
     * vertex-lit and will cast shadows */
    RPAMBOCCLMAPATOMICGETDATA(object)->flags = 0;
    RPAMBOCCLMAPATOMICGETDATA(object)->numSamples = 0;
    /* This means it'll use the global default when a lightmap gets created for it */
    RPAMBOCCLMAPATOMICGETDATA(object)->lightMapSize = 0;
    RPAMBOCCLMAPATOMICGETDATA(object)->lightMap = (RwTexture *)NULL;
    RPAMBOCCLMAPATOMICGETDATA(object)->sampleMap = NULL;
    RPAMBOCCLMAPATOMICGETDATA(object)->clearCol = FALSE;

    RWRETURN(object);
}

static void *
AmbOcclMapAtomicDestructor(void *object,
						   RwInt32 offset,
						   RwInt32 size)
{
    AmbOcclMapObjectData *ambOcclMapObject;

    RWFUNCTION(RWSTRING("AmbOcclMapAtomicDestructor"));

    ambOcclMapObject =
        RPAMBOCCLMAPATOMICGETDATA(object);

    if (NULL != ambOcclMapObject->lightMap)
	{
        RwTextureDestroy(ambOcclMapObject->lightMap);
		ambOcclMapObject->lightMap = NULL;
	}

    if (NULL != ambOcclMapObject->sampleMap)
        _rpAmbOcclMapSampleMapDestroy(ambOcclMapObject->sampleMap);

    ambOcclMapObject->lightMap = NULL;
    ambOcclMapObject->sampleMap = NULL;

    RWRETURN(object);
}

static void *
AmbOcclMapAtomicCopy(void *dstObject,
					 const void *srcObject,
					 RwInt32 offset,
					 RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapAtomicCopy"));

   *RPAMBOCCLMAPATOMICGETDATA(dstObject) = *RPAMBOCCLMAPATOMICGETCONSTDATA(srcObject);

    RWRETURN(dstObject);
}

static void *
AmbOcclMapGeometryConstructor(void *object,
							  RwInt32 offset,
							  RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapGeometryConstructor"));
    
    /* By default it has not yet been light mapped */
    RPAMBOCCLMAPGEOMETRYGETDATA(object)->PolySetArray = NULL;
    
    RWRETURN(object);
}

static void *
AmbOcclMapGeometryDestructor(void *object,
							 RwInt32 offset,
							 RwInt32 size)
{
    AmbOcclMapGeometryData *geometryData = RPAMBOCCLMAPGEOMETRYGETDATA(object);

    RWFUNCTION(RWSTRING("AmbOcclMapGeometryDestructor"));

    if (geometryData->PolySetArray != NULL)
        RwFree (geometryData->PolySetArray);

    RWRETURN(object);
}

static void *
AmbOcclMapGeometryCopy(void *dstObject,
					   const void *srcObject,
					   RwInt32 offset,
					   RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapGeometryCopy"));
    
    *RPAMBOCCLMAPGEOMETRYGETDATA(dstObject) = *RPAMBOCCLMAPGEOMETRYGETCONSTDATA(srcObject);
    
    RWRETURN(dstObject);
}

static RwStream *
AmbOcclMapAtomicRead(RwStream *stream,
					 RwInt32 binaryLength,
					 void *object,
					 RwInt32 offsetInObject,
					 RwInt32 sizeInObject)
{
    AmbOcclMapObjectStreamData streamData;
    AmbOcclMapObjectData *atomicData;
    RpAtomic *atomic;
	RwUInt32 version;

    RWFUNCTION(RWSTRING("AmbOcclMapAtomicRead"));
    RWASSERT(NULL != stream);
    RWASSERT(NULL != object);

    atomic = (RpAtomic *)object;
    RWASSERT(NULL != atomic);

    atomicData = RPAMBOCCLMAPATOMICGETDATA(atomic);

	// version
    if (!RwStreamReadInt32(stream, &version, sizeof(version)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapAtomicRead",
            "Could not read stream version data");
        RWRETURN((RwStream *)NULL);
    }

    /* Once there are multiple plugin data file versions, test 'version' here */
    {
        RWASSERT(binaryLength ==
            (4 +
             sizeof(RwUInt32) + /* flags */
             sizeof(RwUInt32) + /* numSamples */
             sizeof(RwUInt32) + /* lightMapSize */
             (sizeof(RwChar)*rwTEXTUREBASENAMELENGTH) /*lightMapName */));

        /* Read the atomic plugin data */
        if (RwStreamRead(stream, &streamData, sizeof(streamData))
                != sizeof(streamData))
        {
            RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapAtomicRead", "Could not read stream data");
            RWRETURN((RwStream *)NULL);
        }

        /* Convert the stream structure */
        (void)RwMemNative32(&streamData.flags, sizeof(RwUInt32));
        (void)RwMemNative32(&streamData.numSamples, sizeof(RwUInt32));
        /* NOTE: the lightmap name string isn't endianness converted (it's byte data) */
        (void)RwMemNative32(&streamData.lightMapSize, sizeof(RwUInt32));
        /* So we catch when this needs updating: */
        RWASSERT(12 + rwTEXTUREBASENAMELENGTH*sizeof(RwChar) ==
                 sizeof(AmbOcclMapObjectStreamData));

        /* Store the streamed values in plugin data */
        atomicData->flags        = streamData.flags;
        atomicData->numSamples   = streamData.numSamples;
        atomicData->lightMapSize = streamData.lightMapSize;
        /* If the atomic has a lightmap, load it in */
		if (rwstrcmp(streamData.lightMapName, ""))
		{
			RwTexture *texture = (RwTexture*)NULL;
            texture = RwTextureRead(streamData.lightMapName, NULL);
            RWASSERT(NULL != texture);
			atomicData->lightMap = texture;
		}
		else
		{
	        RWASSERT(0 == atomicData->lightMapSize);
		    atomicData->lightMap = (RwTexture *)NULL;
		}
    }

    RWRETURN(stream);
}

static RwStream *
AmbOcclMapAtomicWrite(RwStream *stream,
					  RwInt32 binaryLength,
					  const void *object,
					  RwInt32 offsetInObject,
					  RwInt32 sizeInObject)
{
    AmbOcclMapObjectStreamData streamData;
    const AmbOcclMapObjectData *atomicData;
    const RpAtomic *atomic;
	RwUInt32 version = 0;

    RWFUNCTION(RWSTRING("AmbOcclMapAtomicWrite"));

    atomic = (const RpAtomic *)object;
    RWASSERT(NULL != atomic);

    atomicData = RPAMBOCCLMAPATOMICGETCONSTDATA(atomic);

	// version
    if (!RwStreamWriteInt32(stream, &version, sizeof(version)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapAtomicWrite",
            "Could not write stream version data");
        RWRETURN((RwStream *)NULL);
    }

    /* Fill the stream structure */
    streamData.flags = atomicData->flags;
    /* NOTE: numSamples could be non-zero even if the atomic has
     *       no lightmap, given that we can do vertex lighting. */
    streamData.numSamples = atomicData->numSamples;
    if (NULL != atomicData->lightMap)
    {
        RwTexture *lightMap = atomicData->lightMap;

        rwsprintf(streamData.lightMapName, RwTextureGetName(lightMap));
        streamData.lightMapSize = atomicData->lightMapSize;
        RWASSERT((atomicData->lightMapSize == (RwUInt32)
                  RwRasterGetWidth( RwTextureGetRaster(lightMap))) &&
                 (atomicData->lightMapSize == (RwUInt32)
                  RwRasterGetHeight(RwTextureGetRaster(lightMap))) );
    }
    else
    {
        rwsprintf(streamData.lightMapName, "");
        streamData.lightMapSize = 0;
    }

    /* Convert and write out the stream structure */
    (void)RwMemLittleEndian32(&streamData.flags, sizeof(RwUInt32));
    (void)RwMemLittleEndian32(&streamData.numSamples, sizeof(RwUInt32));
    /* NOTE: the lightmap name string isn't endianness converted (it's byte data) */
    (void)RwMemLittleEndian32(&streamData.lightMapSize, sizeof(RwUInt32));
    /* So we catch when this needs updating: */
    RWASSERT(12 + rwTEXTUREBASENAMELENGTH*sizeof(RwChar) ==
             sizeof(AmbOcclMapObjectStreamData));
    if (!RwStreamWrite(stream, &streamData, sizeof(streamData)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapAtomicWrite",
            "Could not write stream plugin data");
        RWRETURN((RwStream *)NULL);
    }

    RWRETURN(stream);
}

static RwInt32
AmbOcclMapAtomicGetSize(const void *object,
						RwInt32 offsetInObject,
						RwInt32 sizeInObject)
{
    RWFUNCTION(RWSTRING("AmbOcclMapAtomicGetSize"));

    if (RPAMBOCCLMAPATOMICGETCONSTDATA((const RpAtomic *)object)->flags)
    {
        RWRETURN((RwInt32)AMBOCCLMAPOBJECTSTREAMDATASIZE);
    }

    /* Don't bother streaming data if the object is in the default state */
    RWRETURN(0);
}

static void *
AmbOcclMapWorldConstructor(void *object,
						   RwInt32 offset,
						   RwInt32 size)
{
    AmbOcclMapWorldData *data;

    RWFUNCTION(RWSTRING("AmbOcclMapWorldConstructor"));

    data = (AmbOcclMapWorldData *)RPAMBOCCLMAPWORLDGETDATA(object);

    /* This results in a value being automatically calculated,
     * from the world's bounding box, at lightmap-creation-time */
    data->lightMapDensity = 0;
    data->flag = 0;

    RWRETURN(object);
}

/* No need for a world destructor */

static void *
AmbOcclMapWorldCopy(void *dstObject,
					const void *srcObject,
					RwInt32 offset,
					RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapWorldCopy"));
    /* Nahh, not gonna support this */
    RWRETURN(NULL);
}

static RwStream *
AmbOcclMapWorldRead(RwStream *stream,
					RwInt32 binaryLength,
					void *object,
					RwInt32 offsetInObject,
					RwInt32 sizeInObject)
{
    AmbOcclMapWorldStreamData streamData;
    AmbOcclMapWorldData *worldData;
    RpWorld *world;
    RwUInt32 version;

    RWFUNCTION(RWSTRING("AmbOcclMapWorldRead"));
    RWASSERT(NULL != stream);
    RWASSERT(NULL != object);

    world = (RpWorld *)object;
    RWASSERT(NULL != world);

    worldData = RPAMBOCCLMAPWORLDGETDATA(world);

	// version
    if (!RwStreamReadInt32(stream, &version, sizeof(version)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapWorldRead",
            "Could not read stream version data");
        RWRETURN((RwStream *)NULL);
    }

    /* Once there are multiple plugin data file versions, test 'version' here */
    {
        RWASSERT(binaryLength ==
            (4 +
             sizeof(streamData)));

        /* Read the world plugin data */
        if (RwStreamRead(stream, &streamData, sizeof(streamData))
                != sizeof(streamData))
        {
            RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapWorldRead",
                "Could not read stream data");
            RWRETURN((RwStream *)NULL);
        }

        /* Convert it */
        (void)RwMemNative32(&streamData.lightMapDensity, sizeof(RwReal));
        (void)RwMemFloat32ToReal(&streamData.lightMapDensity, sizeof(RwReal));

        /* Fill in the plugin data */
        worldData->lightMapDensity = streamData.lightMapDensity;
    }

    /*else
    {
        RwDebugSendMessage(rwDEBUGERROR, "LtMapWorldRead", "Invalid stream data version");
        RWRETURN((RwStream *)NULL);
    }*/

    /* Flag the world as lightmapped */
    worldData->flag |= rpAMBOCCLMAPWORLDFLAGAMBOCCLMAP;

    RWRETURN(stream);
}

static RwStream *
AmbOcclMapWorldWrite(RwStream *stream,
					 RwInt32 binaryLength,
					 const void *object,
					 RwInt32 offsetInObject,
					 RwInt32 sizeInObject)
{
    AmbOcclMapWorldStreamData streamData;
    const AmbOcclMapWorldData *worldData;
    const RpWorld *world;
	RwUInt32 version = 0;

    RWFUNCTION(RWSTRING("AmbOcclMapWorldWrite"));

    RWASSERT(AMBOCCLMAPWORLDSTREAMDATASIZE == binaryLength);
    RWASSERT(NULL != stream);
    RWASSERT(NULL != object);

    world = (const RpWorld *)object;
    RWASSERT(NULL != world);

    worldData = RPAMBOCCLMAPWORLDGETCONSTDATA(world);

	// version
    if (!RwStreamWriteInt32(stream, &version, sizeof(version)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapWorldWrite",
            "Could not write stream version data");
        RWRETURN((RwStream *)NULL);
    }

    /* Now write out the world plugin data */
    streamData.lightMapDensity = worldData->lightMapDensity;

    (void)RwMemRealToFloat32(&streamData.lightMapDensity, sizeof(RwReal));
    (void)RwMemLittleEndian32(&streamData.lightMapDensity, sizeof(RwReal));

    if (!RwStreamWrite(stream, &streamData, sizeof(streamData)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapWorldWrite", "Could not write stream plugin data");
        RWRETURN((RwStream *)NULL);
    }

    RWRETURN(stream);
}

static RwInt32
AmbOcclMapWorldGetSize(const void *object,
					   RwInt32 offsetInObject,
					   RwInt32 sizeInObject)
{
    const AmbOcclMapWorldData *worldData;

    RWFUNCTION(RWSTRING("AmbOcclMapWorldGetSize"));

    worldData = RPAMBOCCLMAPWORLDGETCONSTDATA((const RpWorld *)object);

    if (worldData->flag & rpAMBOCCLMAPWORLDFLAGAMBOCCLMAP)
    {
        RWRETURN((RwInt32)AMBOCCLMAPWORLDSTREAMDATASIZE);
    }

    /* Don't bother streaming data if the object is in the default state */
    RWRETURN(0);
}

static void *
AmbOcclMapMaterialConstructor(void *object,
							  RwInt32 offset,
							  RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapMaterialConstructor"));

    /* By default materials are lightmapped, don't emit light, do
     * cast shadows, aren't flat-shaded [and aren't translucent] */
    RPAMBOCCLMAPMATERIALGETDATA(object)->flags   = 0;
    /* This multiplies the world's lightmap density */
    RPAMBOCCLMAPMATERIALGETDATA(object)->lightMapDensity = 1.0f;

    RWRETURN(object);
}

static void *
AmbOcclMapMaterialCopy(void *dstObject,
					   const void *srcObject,
					   RwInt32 offset,
					   RwInt32 size)
{
    RWFUNCTION(RWSTRING("AmbOcclMapMaterialCopy"));

   *RPAMBOCCLMAPMATERIALGETDATA(dstObject) = *RPAMBOCCLMAPMATERIALGETCONSTDATA(srcObject);

    RWRETURN(dstObject);
}

/*
 * AmbOcclMapMaterialDestroy() is not needed.
 */

static RwStream *
AmbOcclMapMaterialRead(RwStream *stream,
					   RwInt32 binaryLength,
					   void *object,
					   RwInt32 offsetInObject,
					   RwInt32 sizeInObject)
{
    AmbOcclMapMaterialStreamData streamData;
    AmbOcclMapMaterialData *materialData;
    RpMaterial *material;
    RwUInt32 version;

    RWFUNCTION(RWSTRING("AmbOcclMapMaterialRead"));
    RWASSERT(NULL != stream);
    RWASSERT(NULL != object);

    material = (RpMaterial *)object;
    RWASSERT(NULL != material);

    materialData = RPAMBOCCLMAPMATERIALGETDATA(material);

	// version
    if (!RwStreamReadInt32(stream, &version, sizeof(version)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapMaterialRead",
            "Could not read stream version data");
        RWRETURN((RwStream *)NULL);
    }

    /* Once there are multiple plugin data file versions, test 'version' here */
    {
        RWASSERT(binaryLength ==
            (4 +
             sizeof(RwUInt32) + /* flags */
             sizeof(RwReal)     /* lightMapDensity */));

        /* Read the material plugin data */
        if (RwStreamRead(stream, &streamData, sizeof(streamData))
                != sizeof(streamData))
        {
            RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapMaterialRead", "Could not read stream data");
            RWRETURN((RwStream *)NULL);
        }

        /* Convert it */
        (void)RwMemNative32(&streamData.flags, sizeof(RwUInt32));
        (void)RwMemNative32(&streamData.lightMapDensity, sizeof(RwReal));
        (void)RwMemFloat32ToReal(&streamData.lightMapDensity, sizeof(RwReal));

        materialData->flags            = streamData.flags;
        materialData->lightMapDensity  = streamData.lightMapDensity;
    }
    /*else
    {
        RwDebugSendMessage(rwDEBUGERROR, "LtMapMaterialRead", "Invalid stream data version");
        RWRETURN((RwStream *)NULL);
    }*/

    RWRETURN(stream);
}

static RwStream *
AmbOcclMapMaterialWrite(RwStream *stream,
						RwInt32 binaryLength,
						const void *object,
						RwInt32 offsetInObject,
						RwInt32 sizeInObject)
{
    AmbOcclMapMaterialStreamData streamData;
    const AmbOcclMapMaterialData *materialData;
    const RpMaterial *material;
    RwUInt32 version = 0;

    RWFUNCTION(RWSTRING("AmbOcclMapMaterialWrite"));

    material = (const RpMaterial *)object;
    RWASSERT(NULL != material);
    materialData = RPAMBOCCLMAPMATERIALGETCONSTDATA(material);

	// version
    if (!RwStreamWriteInt32(stream, &version, sizeof(version)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapMaterialWrite",
            "Could not write stream version data");
        RWRETURN((RwStream *)NULL);
    }

    /* Fill and write out the stream structure */
    streamData.flags            = materialData->flags;
    streamData.lightMapDensity  = materialData->lightMapDensity;

    (void)RwMemLittleEndian32(&streamData.flags, sizeof(RwUInt32));
    (void)RwMemRealToFloat32(&streamData.lightMapDensity, sizeof(RwReal));
    (void)RwMemLittleEndian32(&streamData.lightMapDensity, sizeof(RwReal));

    if (!RwStreamWrite(stream, &streamData, sizeof(streamData)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "AmbOcclMapMaterialWrite",
            "Could not write stream plugin data");
        RWRETURN((RwStream *)NULL);
    }

    RWRETURN(stream);
}

static RwInt32
AmbOcclMapMaterialGetSize(const void *object,
						  RwInt32 offsetInObject,
						  RwInt32 sizeInObject)
{
    RWFUNCTION(RWSTRING("AmbOcclMapMaterialGetSize"));

    if (RPAMBOCCLMAPMATERIALGETCONSTDATA((const RpMaterial *)object)->flags)
    {
        RWRETURN((RwInt32)AMBOCCLMAPMATERIALSTREAMDATASIZE);
    }

    /* Don't bother streaming data if the object is in the default state */
    RWRETURN(0);
}

RwBool
RpAmbOcclMapPluginAttach(void)
{
    RwInt32 success;
	int offset;

    RWAPIFUNCTION(RWSTRING("RpAmbOcclMapPluginAttach"));

    /* Register the plugIn */
    offset =
        RwEngineRegisterPlugin(0,
                               rwID_AMBOCCLMAPPLUGIN,
                               AmbOcclMapOpen,
                               AmbOcclMapClose);
    RWASSERT(0 < offset);

    /* Extend atomic to hold lightmap pointer. */
    _rpAmbOcclMapGlobals.atomicOffset =
        RpAtomicRegisterPlugin(sizeof(AmbOcclMapObjectData),
                               rwID_AMBOCCLMAPPLUGIN,
                               AmbOcclMapAtomicConstructor,
                               AmbOcclMapAtomicDestructor,
                               AmbOcclMapAtomicCopy);
    RWASSERT(0 < _rpAmbOcclMapGlobals.atomicOffset);


    /* Extend geometry to hold 'lightmapped' flag */
    _rpAmbOcclMapGlobals.geometryOffset =
        RpGeometryRegisterPlugin(sizeof(AmbOcclMapGeometryData),
							     rwID_AMBOCCLMAPPLUGIN,
						         AmbOcclMapGeometryConstructor,
                                 AmbOcclMapGeometryDestructor,
                                 AmbOcclMapGeometryCopy);
    RWASSERT(0 < _rpAmbOcclMapGlobals.geometryOffset);
   
    /* Attach the stream handling functions. */
    success = RpAtomicRegisterPluginStream(rwID_AMBOCCLMAPPLUGIN,
                                           AmbOcclMapAtomicRead,
                                           AmbOcclMapAtomicWrite,
                                           AmbOcclMapAtomicGetSize);
    RWASSERT(0 < success);

    /* Extend world to hold lightmap list. */
    _rpAmbOcclMapGlobals.worldOffset =
        RpWorldRegisterPlugin(sizeof(AmbOcclMapWorldData),
                                    rwID_AMBOCCLMAPPLUGIN,
                                    AmbOcclMapWorldConstructor,
                                    NULL,
                                    AmbOcclMapWorldCopy);

    RWASSERT(0 < _rpAmbOcclMapGlobals.worldOffset);

    /* Attach the stream handling functions. */
    success = RpWorldRegisterPluginStream(rwID_AMBOCCLMAPPLUGIN,
                                          AmbOcclMapWorldRead,
                                          AmbOcclMapWorldWrite,
                                          AmbOcclMapWorldGetSize);
    RWASSERT(0 < success);

    /* Extend material to hold area-lighting info. */
    _rpAmbOcclMapGlobals.materialOffset =
        RpMaterialRegisterPlugin(sizeof(AmbOcclMapMaterialData),
                                 rwID_AMBOCCLMAPPLUGIN,
                                 AmbOcclMapMaterialConstructor,
                                 NULL,
                                 AmbOcclMapMaterialCopy);
    RWASSERT(0 < _rpAmbOcclMapGlobals.materialOffset);

    /* Attach the stream handling functions. */
    success = RpMaterialRegisterPluginStream(rwID_AMBOCCLMAPPLUGIN,
                                             AmbOcclMapMaterialRead,
                                             AmbOcclMapMaterialWrite,
                                             AmbOcclMapMaterialGetSize);
    RWASSERT(0 < success);

     _rpAmbOcclMapGlobals.rasFormat = rwRASTERTYPETEXTURE|rwRASTERFORMAT888|
									  rwRASTERFORMATMIPMAP|rwRASTERFORMATAUTOMIPMAP;

    RWRETURN(TRUE);
}

RwBool
RpAmbOcclMapSetRenderStyle(RpAmbOcclMapStyle style, RpWorld *world)
{
//    RWAPIFUNCTION(RWSTRING("RpLtMapSetRenderStyle"));
//    RWASSERT(0 < _rpLtMapGlobals.module.numInstances);
//
//    if (NULL != world)
//    {
//        RwTextureFilterMode filtering = rwFILTERNEAREST;
//        RwUInt32 format = RpLtMapGetRasterFormat();
//        RwSList *lightMapList;
//        RwTexture *result;
//        RwUInt32 i;
//
//        if (!(style & 4))
//        {
//            filtering = rwFILTERLINEAR;
//            if (format & rwRASTERFORMATMIPMAP)
//            {
//                filtering = rwFILTERLINEARMIPLINEAR;
//            }
//        }
//
//        lightMapList = LtMapWorldLightMapListCreate(world);
//        RWASSERT(NULL != lightMapList);
//
//        /* LM filtering */
//        for (i = 0;i < (RwUInt32)rwSListGetNumEntries(lightMapList);++i)
//        {
//            result = RwTextureSetFilterMode(*(RwTexture **)
//                         rwSListGetEntry(lightMapList, i), filtering);
//        }
//
//        rwSListDestroy(lightMapList);
//    }
//
//    /* Render modes are {base,LM,base+LM} */
///* TODO[5][ACM]: all pipelines should #predicate renderStyle on
// * RWDEBUG {esp. PS2!} */
//    _rpLtMapGlobals.renderStyle = style;

    RWRETURN(TRUE);
}

RpAmbOcclMapStyle
RpAmbOcclMapGetRenderStyle(void)
{
    //const RpLtMapStyle result = (RpLtMapStyle)_rpLtMapGlobals.renderStyle;
    //RWAPIFUNCTION(RWSTRING("RpLtMapGetRenderStyle"));

    //RWASSERT(0 < _rpLtMapGlobals.module.numInstances);

    //RWRETURN(result);
	RWRETURN(0);
}

RwTexture *
RpAmbOcclMapAtomicGetAmbOcclMap(RpAtomic *atomic)
{
    RwTexture *result;

    RWAPIFUNCTION(RWSTRING("RpAmbOcclMapAtomicGetAmbOcclMap"));
    RWASSERT(NULL != atomic);

    result = RPAMBOCCLMAPATOMICGETDATA(atomic)->lightMap;

    RWRETURN(result);
}

RpAtomic *
RpAmbOcclMapAtomicSetAmbOcclMap(RpAtomic *atomic, RwTexture *ambOcclMap)
{
    RwTexture *oldAmbOcclMap;
    RwRaster  *raster;
    RwUInt32   width;

    RWAPIFUNCTION(RWSTRING("RpAmbOcclMapAtomicSetAmbOcclMap"));
    RWASSERT(NULL != atomic);
    RWASSERT(NULL != ambOcclMap);

    raster = RwTextureGetRaster(ambOcclMap);
    width  = RwRasterGetWidth(raster);
    if (width != (RwUInt32)RwRasterGetHeight(raster))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RpAmbOcclMapAtomicSetAmbOcclMap",
            "Lightmaps must be square");
        RWRETURN((RpAtomic *)NULL);
    }
    if (width & (width - 1))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RpAmbOcclMapAtomicSetAmbOcclMap",
            "Lightmaps must have power-of-two side length");
        RWRETURN((RpAtomic *)NULL);
    }
    /* Update to the new size */
    RPAMBOCCLMAPATOMICGETDATA(atomic)->lightMapSize = width;

    oldAmbOcclMap = RPAMBOCCLMAPATOMICGETDATA(atomic)->lightMap;
    RPAMBOCCLMAPATOMICGETDATA(atomic)->lightMap = ambOcclMap;
	//@{ Jaewon 20041222
	RwTextureAddRef(ambOcclMap);
	//@} Jaewon
    if (NULL != oldAmbOcclMap)
    {
        /* Decrement the refCount of the old lightmap */
        RwTextureDestroy(oldAmbOcclMap);
		oldAmbOcclMap = NULL;
    }

    RWRETURN(atomic);
}

static RpAtomic *
AtomicLightMapListCB(RpAtomic *atomic, void *data)
{
    RwSList *lightMapList = (RwSList *)data;
    RwTexture *lightMap;
    RwUInt32 i;

    RWFUNCTION(RWSTRING("AtomicLightMapListCB"));

    lightMap = RpAmbOcclMapAtomicGetAmbOcclMap(atomic);
    if (NULL != lightMap)
    {
        for (i = 0;i < (RwUInt32)rwSListGetNumEntries(lightMapList);++i)
        {
            if (lightMap == *(RwTexture **)rwSListGetEntry(lightMapList, i))
            {
                lightMap = (RwTexture *)NULL;
                break;
            }
        }
        if (lightMap != NULL)
        {
            *(RwTexture **)rwSListGetNewEntry(lightMapList,
                rwID_AMBOCCLMAPPLUGIN | rwMEMHINTDUR_EVENT) = lightMap;
        }
    }

    RWRETURN(atomic);
}

static RpWorldSector *
SectorLightMapListCB(RpWorldSector *sector, void *data)
{
    RwSList *lightMapList = (RwSList *)data;
    //RwTexture *lightMap;
    //RwUInt32 i;

    RWFUNCTION(RWSTRING("SectorLightMapListCB"));

    RpWorldSectorForAllAtomics(sector, AtomicLightMapListCB, data);

    RWRETURN(sector);
}

static RwSList *
LtMapWorldLightMapListCreate(RpWorld *world)
{
    RwSList *lightMapList;

    RWFUNCTION(RWSTRING("LtMapWorldLightMapListCreate"));
    RWASSERT(NULL != world);

    lightMapList = rwSListCreate(sizeof(RwTexture *),
        rwID_AMBOCCLMAPPLUGIN | rwMEMHINTDUR_EVENT);
    RWASSERT(NULL != lightMapList);

    RpWorldForAllWorldSectors(world, SectorLightMapListCB, (void *)lightMapList);

    RWRETURN(lightMapList);
}

RwUInt32
RpAmbOcclMapWorldAmbOcclMapsQuery(RpWorld *world)
{
    RwSList *lightMapList;
    RwUInt32 numLightMaps;

    RWAPIFUNCTION(RWSTRING("RpAmbOcclMapWorldAmbOcclMapsQuery"));
    RWASSERT(NULL != world);

    lightMapList = LtMapWorldLightMapListCreate(world);
    RWASSERT(NULL != lightMapList);
    numLightMaps = rwSListGetNumEntries(lightMapList);
    rwSListDestroy(lightMapList);

    RWRETURN(numLightMaps);
}

RwUInt32
RpAmbOcclMapGetRasterFormat(void)
{
    RWAPIFUNCTION(RWSTRING("RpAmbOcclMapGetRasterFormat"));

    RWRETURN(_rpAmbOcclMapGlobals.rasFormat);
}

RwBool
RpAmbOcclMapSetRasterFormat(RwUInt32 format)
{
    RWAPIFUNCTION(RWSTRING("RpAmbOcclMapSetRasterFormat"));

    /* Check the new format is a texture. */
    RWASSERT(format & rwRASTERTYPETEXTURE);

     _rpAmbOcclMapGlobals.rasFormat = format;

    RWRETURN(TRUE);
}

RwTexture *
_rpLtMapClearLightMap(RwTexture *lightMap, RwRGBA *color)
{
    RwRGBA    colors[2] = {{255, 255, 255, 255}, {  0,  0,  0, 255}};
    RwRaster *raster;
    RwImage  *image;
    RwUInt32  width, height, stride;
    RwUInt8  *pixels;
    RwUInt32  x, y;

    RWFUNCTION(RWSTRING("_rpLtMapClearLightMap"));

    RWASSERT(NULL != lightMap);
    raster = RwTextureGetRaster(lightMap);
    RWASSERT(NULL != raster);

    width  = RwRasterGetWidth( raster);
    height = RwRasterGetHeight(raster);
    image = RwImageCreate(width, height, 32);
    RWASSERT(NULL != image);
    RwImageAllocatePixels(image);

    /* Clear all texels to an "unused" value */
/* TODO[6]: FILL WITH A CHECKERBOARD FOR DEBUG PURPOSES
 * - WE SHOULD CREATE AXIS-DEPENDENT CHECKERBOARDS, ALTERNATING BETWEEN "AXIS-COLOUR" AND BLACK.
 * - THIS WOULD REQUIRE FILLING IN TRIANGLES NOT ENTIRE RASTERS :O/
 * - IT'S OK, THERE'S CODE FOR IT IN RenderEngine (DEBUG-PREDICATED)
 * - REMEMBER THAT THE 'AXIS' VALUES ARE NOW ENCODED IN THE BOTTOM 3 BITS OF THE UVs */

    /* Users can override the colour (not alpha though) */
    if (NULL != color)
    {
        colors[0]       = *color;
        colors[0].alpha = 255;
        colors[1]       = *color;
        colors[1].alpha = 255;
    }

    stride = RwImageGetStride(image);
    pixels = RwImageGetPixels(image);
    RWASSERT(NULL != pixels);
    for (y = 0;y < height;++y)
    {
        RwRGBA *pixel = (RwRGBA *)&(pixels[y*stride]);
        for (x = (y&1);x < (width + (y&1));++x)
        {
           *pixel = colors[x&1];
            ++pixel;
        }
    }

    RwRasterSetFromImage(raster, image);
    RwImageDestroy(image);

    RWRETURN(lightMap);
}

rpLtMapSampleMap *
_rpLtMapSampleMapCreate( RwUInt32 w, RwUInt32 h )
{
    rpLtMapSampleMap      *sampleMap;
    RwUInt32            size;

    RWFUNCTION(RWSTRING("_rpLtMapSampleMapCreate"));

    RWASSERT(w > 0);
    RWASSERT(h > 0);

    size = sizeof(rpLtMapSampleMap);
    size += RPLTMAPSAMPLEMAPSIZE(w, h);

    sampleMap = (rpLtMapSampleMap *) RwMalloc(size,
        rwID_AMBOCCLMAPPLUGIN | rwMEMHINTDUR_EVENT);
    if (NULL != sampleMap)
    {
        sampleMap->samplePixels = (RwUInt8 *)
            (((RwChar *) sampleMap) + sizeof(rpLtMapSampleMap));

        sampleMap->refCount = 1;

        memset(sampleMap->samplePixels, 0, (size - sizeof(rpLtMapSampleMap)));
    }

    RWRETURN(sampleMap);
}

extern RwBool
_rpLtMapSampleMapDestroy( rpLtMapSampleMap *sampleMap )
{
    RWFUNCTION(RWSTRING("_rpLtMapSampleMapDestroy"));

    RWASSERT(sampleMap);
    RWASSERT(sampleMap->refCount > 0);

    --sampleMap->refCount;
    if (sampleMap->refCount == 0)
    {
        RwFree(sampleMap);
    }

    RWRETURN(TRUE);
}